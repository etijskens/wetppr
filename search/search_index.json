{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wellcome at Parallel programming","text":""},{"location":"#welkom-bij-parallel-programmeren","title":"Welkom bij Parallel programmeren","text":"<p>Material for the course 2000wetppr of the University of Antwerp</p> <p></p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Over de auteur</li> <li>Overview</li> <li>Glossary</li> <li>Links</li> <li>Chapter 1 - Introduction</li> <li>Chapter 2 - Aspects of modern CPU architecture</li> <li>Chapter 3 - Optimise first, then parallelize</li> <li>Chapter 4 - Case studies</li> <li>Chapter 5 - A strategy for the development research software</li> <li>Evaluation</li> <li>VSC infrastructure</li> </ol>"},{"location":"assignment-2022-23/","title":"Assignment 2022-23","text":""},{"location":"assignment-2022-23/#the-mandelbrot-set","title":"The Mandelbrot set","text":"<p>The Mandelbrot set  is defined as the set of all complex numbers  c \\in \\mathbb{C} , for which the  iterative scheme </p> <p>  z_0 = 0   z_{i+1} = z_{i}^2 + c  </p> <p>is bounded, i.e. </p> <p>  \\forall i \\in \\mathbb{N}, \\left|z_{i}\\right| \\le b \\in \\mathbb{R}^+  </p> <p>It can be demonstrated that, if for some i,  \\left|z_{i}\\right| &gt; 2 , the iteration is  guaranteed to be unbounded, and thus c \\notin \\mathcal{M}. This yields a practical criterion to compute an approximate Mandelbrot set  \\mathcal{M}_N, containing as all complex numbers for which the first N iterations remain inside the circle with radius 2 (centered at the origin), i.e. for which  \\left|z_{i}\\right| \\le 2  for all  i\\le{N}.</p> <p>The Mandelbrot set \\mathcal{M}, or its approximation \\mathcal{M}_N, is traditionally coloured black, while the  other points, the points escaping outside the circle with radius 2 towards infinity, get a colour that indicates how  fast they escape. Here is an example (from wikipedia):</p> <p></p> <p>Here is the challenge for you.</p>"},{"location":"assignment-2022-23/#the-mandelbrot-challenge","title":"The Mandelbrot challenge","text":"<p>Take the complex numbers c \\in \\mathbb{C} for which \\Re(c) \\in \\left[-2,1\\right] and \\Im(c) \\in \\left[0, 4/3\\right], i.e. about the upper half of the figure above (the lower half is symmetric). Compute the approximate  mandelbrot sets \\mathcal{M}_{100}, \\mathcal{M}_{1000} and \\mathcal{M}_{10000} with pixel densities d of 100,  500, and 2500 pixels per unit length. You may use the center of the pixels for the points c. Time each of these 9  cases. The rectangle measures 3 by 4/3, so you get images of 300 \\times 133 \\approx 40000 pixels, 1500 \\times  667 \\approx 10^6 pixels, and 7500 \\times 3333 \\approx 25\\times10^6 pixels, resp. </p> <p>It is best to choose the array of pixels such that the coordinate axes pass through the center of pixels. Thus, the  complex number corresponding to a pixel, that is the pixel's center, is always given by </p> <p> c_{mn} = \\frac{m}{d} + i\\mkern1mu\\frac{n}{d} </p> <p>with m and n integer constants.   </p> walltime[s] d=50 d=500 d=5000 sum N=100 N=1000 N=10000 sum Total <p>This a competition! The winner, that is the one with the smallest total compute time Total over the 9 cases,  will get 5 points, the second one 4 points, and so on. The remaining 15 points are to be earned on the presentation.</p> <p>As in every competition, there are a few rules:</p> <ul> <li>Your code must be a Python program, but you may use C++ or Fortran to build your own Python modules for speed.</li> <li>The timings must be run on a single compute node of Vaughan,    the Tier-2 VSC-cluster of the University of Antwerp. Every compute node on Vaughan has 64 cores, all of which you can    use to    parallellise the work and increase the througput. </li> <li>Every case must be computed in at most one job. If you like, you may run all cases together in one job, but    splitting a case over more jobs is not allowed.</li> <li>Obviously, the github repo that you will use to store the different versions of your code, the presentation and    the results, must contain all necessary files to rerun your program, as to verify the correctness of the results and    the timings. </li> <li>You must save the image to disk. However, the timing must only include computing the image, not saving it to disk.  </li> </ul> <p>Success! </p>"},{"location":"assignment-2022-23/#plotting-the-images","title":"Plotting the images","text":"<p>Getting the nice images of the Mandelbrot set you may encounter on the web isn't as easy as it seems. Although this is  not part of the challenge, I can understand your dissappointment if after spending all the effort to optimise and  parallelise your codes, the images do not match your expectations. However, your get a long way by applying a  transformation to the escape count (the pixel value), and mapping that to a color map. Here are some pointers:</p> <ul> <li>Plotting algorithms for the Mandelbrot set</li> <li>A related question on stackoverflow</li> <li>How to plot the mandelbrot set - adding some colors</li> </ul>"},{"location":"chapter-1/","title":"Chapter 1 - Introduction","text":"<p>Material:</p> <ul> <li>this text and</li> <li>this presentation.</li> </ul>"},{"location":"chapter-1/#overview","title":"Overview","text":"<ul> <li>What is a parallel program?</li> <li>Possible reasons to parallelize a program.</li> </ul>"},{"location":"chapter-1/#what-is-a-parallel-program","title":"What is a parallel program?","text":"<p>A parallel program is a program that distributes its work over different processing units such that parts of its  work load can be computed simultaneously. At the end the program gathers the partial results from the processing  units and combines them in a global result. If the tasks are independent of each other, the program is called  embarrassingly parallel. In general, the individual tasks are not independent and need to exchange information.  This is called communication. The opposite of a parallel program is a serial or sequential program,  executing all its instructions one after the other. </p>"},{"location":"chapter-1/#possible-reasons-to-parallelize-a-program","title":"Possible reasons to parallelize a program","text":""},{"location":"chapter-1/#1-reduce-the-time-to-solution","title":"1. Reduce the time to solution","text":"<p>The term time to solution in general means the time your machine needs to solve a computational problem. If the  problem can be divided in smaller tasks that can be computed simultaneously, the time to solution decreases. If a  company can solve a research or engineering question in a week or a day, that is an important difference. A  processing unit has a maximum number of instructions it can execute per second, this is called its peak  performance. Obviously, the peak performance is a machine limit puts a hard limit to what a processing unit can  achieve in a given amount of time. But instructions operate on data, and moving data from main memory takes time as  well. A program that must process lots of data but does little computation is limited by the speed at which the  processing unit can fetch data from the main memory. This is called the memory bandwidth (usually in Mbits/s). Programs that do a lot of computation and does not move a lot of data in or out of main memory is called compute  limited. A program that moves a lot of data and little computation is bandwidth limited. While in the past  programs used to be compute bound, today, most programs are memory bound, because the speed of the processing units  increased much faster than the speed of memory. As a consequence, efficient memory access patterns are crucial to the  performance of a program.  </p>"},{"location":"chapter-1/#2-solve-bigger-problems-in-the-same-time","title":"2. Solve bigger problems in the same time","text":"<p>There is a third machine limit that plays a role, namely the amount of main memory. This puts a limit on the size of  the problem that can be treated, e.g. the number of volume elements in a CFD simulation or the number of atoms in a  MD simulation. If the program can distribute the work over, say 10 machines, it has 10 times the amount of memory at  its disposition and thus can solve a 10 times bigger problem.  </p>"},{"location":"chapter-1/#3-produce-more-accurate-solutions","title":"3. Produce more accurate solutions","text":"<p>More accuracy can come from more complex physical models, or from using more basis functions to expand the solution. This leads to more computation and perhaps a prohibitively long time to solution. Problems involving discretisation  (the process of dividing the domain of a computational problem in small elements, as in computational fluid dynamics  and finite element modelling) the accuracy typically improves when the elements get smaller, as in approximating the  integral under a curve by rectangles. In both cases parallelization of the program may be necessary to obtain a  solution. </p>"},{"location":"chapter-1/#4-competition","title":"4 Competition","text":"<p>If a program that is in competition with other programs that solve the same problem, parallelization will allow it  to reduce the time to solution, to compute bigger problems and achieve more accurate solution. This is, obviously, a  competitive advantage.  </p>"},{"location":"chapter-1/#cant-i-just-by-a-faster-and-bigger-computer","title":"Can't I just by a faster and bigger computer?","text":"<p>Nope, that fairy tale ended approximately at the beginning of this century with the advent of the multi-processor  computer, also called multi-core computer. Increasing the peak performance by increasing the clock frequency was no  longer possible, because the power consumption of a processor increases as the third power of the clock frequency.  At a certain point it became impossible or too expensive to cool the processor. The only way to get a processor  execute more instructions per second was to put more processing units on it (cores). At that point serial program  became even slower on the new multi-processors because the clock frequency was reduced to remain inside the power  envelope. Moore's law predicts that the number of transistors in a processor doubles every 18 months due to  increasing miniaturization. With this the combined peak performance of the multi-processors increases as well, but  the peak performance of the individual processing units no longer does. This makes it necessary to parallelize  programs in order to keep up with Moore's law. It must be said that the increase of peak performance was not always  in line with Moore's law. At some point the peak performance of processing units was increased by adding  parallelization concept in single processing units like pipelining and SIMD vectorisation. We'll come to that later.</p>"},{"location":"chapter-2/","title":"Chapter 2 - Aspects of modern CPU architecture","text":"<p>You do not have to be a CPU architecture specialist in order to be able to write efficient code. However, there are  a few aspects of CPU architecture that you should understand.</p>"},{"location":"chapter-2/#the-hierarchical-structure-of-cpu-memory","title":"The hierarchical structure of CPU Memory","text":"<p>CPU memory of modern CPUs is hierarchically organised. The memory levels close to the processor need to be fast, to  serve it with data so that it can continue its work. As fast memory is expensive, the levels close to the processor  are also smaller. The farther away from the processor the bigger they are, but also the slower.    </p> <ul> <li>Each processing unit (or core) has a number of registers (~1 kB) and vector registers on which instructions can    immediately operate (latency = 0 cycles). The registers are connected to  </li> <li>a dedicated L1 cache (~32 kB per core), with a latency of ~ 1 cycle. This is in turn    connected to:  </li> <li>a dedicated L2 cache, (~256 kB per core), with a latency of ~10 cycles. This is in turn connected to: </li> <li>the L3 cache, which is shared among a group of cores, (~2 MB per core), with a latency of ~50 cycles.    This is connected to:</li> <li>the main memory, which is shared by all cores,(256 GB - 2 TB), with a latency of ~200 cycles.</li> </ul> <p>The cores and the caches are on the same chip. For this reason they are considerably faster than the main memory.  Faster memory is more expensive and therefor smaller. The figure below illustrates the layout.</p> <p></p> <p>The I/O hub connects the cpu to the outside world, hard disk, network, ...</p> <p>When an instruction needs a data item in a register, the CPU  looks first in the L1 cache, if it is there it will it to the register that was requested. Otherwise, the CPU looks  in L2. If it is there, it is copied to L1 and the register. Otherwise, the CPU looks in L3. If it is there, it is  copied to L2, L1 and the register. Otherwise, the CPU looks copies the cache line surrounding the data item to  L3, L2, L1 and the data item itself to the register. A cache line is typically 64 bytes long and thus can contain 4  double precision floating point numbers or 8 single precision numbers. The main consequence of this strategy is that  if the data item is part of an array, the next elements of that array will also be copied to L1 so that when  processing the array the latency associated with main memory is amortized over 4 or 8 iterations. In addition, the  CPU will notice when it is processing an array and prefetch the next cache line of the array in order to avoid that  the processor has to wait for the data again. This strategy for loading data leads to two important best practices for  making optimal use of the cache.</p> <ol> <li>Exploit Spatial locality: Organize your data layout in main memory in a way that data in a cache line are mostly     needed together. </li> <li>Exploit Temporal locality: Organize your computations in a way that once a cache line is in L1 cache, as much as     possible computations on that data are carried out. This favors a high computational intensity (see below).     Common techniques for this are loop fusion and tiling. </li> </ol>"},{"location":"chapter-2/#loop-fusion","title":"Loop fusion","text":"<p>Here are two loops over an array <code>x</code>:</p> <pre><code>for xi in x:\n    do_something_with(xi)\nfor xi in x:\n    do_something_else_with(xi)\n</code></pre> <p>If the array <code>x</code> is big, too big to fit in the cache, the above code would start loading <code>x</code> elements into the cache, cach line by cache line. Since <code>x</code> is to large to fit in the cache, at some point, when the cache is full, the CPU  will start to evict the cache lines that were loaded long time a go ane are no more used to replace them with new  cache lines. By the time the first loop finishes, the entire beginning of the <code>x</code> array has been evicted and the  scond loop can start to transfer <code>x</code> again from the main memory to the registers, cache line by cache lina. this  violiate the temporal locality principle. So, it incurs twice the data traffic. Loop fusion fuses the two loops into  one and does all computations needed on <code>xi</code> when it is in the cache. </p> <pre><code>for xi in x:\n    do_something_with(xi)\n    do_something_else_with(xi)\n</code></pre> <p>The disadvantage of loop fusion is that the body of the loop may become too large and require more vector registers  than are available. At that point some computations may be done sequentially and performance may suffer. </p>"},{"location":"chapter-2/#tiling","title":"Tiling","text":"<p>Tiling is does the opposite. Ik keeps the loops separate but restricts them to chunks of <code>x</code> which fit in L1 cache.</p> <pre><code>for chunk in x: # chunk is a slice of x that fits in L1\n    for xi in chunk:\n        do_something_with(xi)\n    for xi in chunk:\n        do_something_else_with(xi)\n</code></pre> <p>Again all computations that need to be done to <code>xi</code> are done when it is in L1 cache. Again the entire <code>x</code> array is  transferred only once to the cache. A disadvantage of tiling is that the chunk size needs to be tuned to the size of  L1, which may differ on different machines. Thus, this approach is not cache-oblivious. Loop fusion, on the  other hand, is cache-oblivious.</p> <p>A good understanding of the workings of the hierarchical structure of processor memory is required to write  efficient programs. Although, at first sight, it may seem an overly complex solution for a simple problem, but it is  a good compromise to the many faces of a truly complex problem.\\</p> <p>Tip</p> <p>An absolute must-see for this course is the excellent presentation on this matter by Scott Meyers:  CPU Caches and Why You Care.  (We can also recommend all his  books on C++).</p>"},{"location":"chapter-2/#intra-core-parallellisation-features","title":"Intra-core parallellisation features","text":"<p>Modern CPUs are designed to (among other things) process loops as efficiently as possible, as loops typically  account for a large part of the work load of a program. To make that possible CPUs use two important concepts:  instruction pipelining (ILP) and SIMD vectorisation. </p>"},{"location":"chapter-2/#instruction-pipelining","title":"Instruction pipelining","text":"<p>Instruction pipelining is very well explained here.</p> <p>Basically, instructions are composed of micro-instructions (typically 5: instruction Fetch (IF), instruction decode  (ID), execute (EX), memory access (MEM), write back (WB), details here), each of which are executed in separate  hardware units of the CPU. By executing the instructions sequentially, only one of those units would be active at a  time: namely, the unit responsible for the current micro-instruction. By adding extra instruction registers, all  micro-instruction hardware units can work simultaneously, but on micro-instructions pertaining to different but  consecutive instructions. In this way, on average 5 (typically) instructions are being executed in parallel. This is  very useful for loops.</p> <p>Executing micro-instructions serially, without pipelining:</p> <p></p> <p>Pipelined execution of micro-instructions, in the middle part 5 micro-instructions are executed simultaneously,  which means that on average 5 instructions are executed simultaneously:</p> <p></p> <p>There are a couple of problems that may lead to pipeline stalls, situations where the  pipeline comes to halt. </p> <ol> <li>A data element is requested that is not in the L1 cache. It must be fetched from deeper cache levels or even     from main memory. This is called a cache miss. A L1 cache miss means that the data is not found in L1, but is     found in L2. In a L2 cache miss it is not found in L2 but it is in L3, and a L3 cache miss, or a cache miss tout     court* de data is not found in L3 and has to be fetched from main memory. The pipeline stops executing for a     number of cycles corresponding to the latency of that cache miss. Data cache misses are the most important cause     of pipeline stalls and as the latency can be really high (~100 cycles).  </li> <li>A instruction is needed that is not in the L1 instruction cache. This may sometimes happen when a (large)     function is called that is not inlined. Just as for a data cache miss, the pipeline stalls for a number of cycles     corresponding to the latency of the cache miss, just as for a data cache miss. </li> <li>You might wonder how a pipeline proceeds when confronted with a branching instruction, a condition that has to be     tested, and must start executing different streams of instructions depending on the outcome (typically     if-then-else constructs). Here's the thing: it guesses the outcome of the test and starts executing the     corresponding branch. As soon as it notices that it guessed wrong, which is necessarily after the condition has been     tested, it stops, steps back and restarts at the correct branch. Obviously, the performance depends on how well     it guesses. The guesses are generally rather smart. It is able to recognize temporal patterns, and if it doesn't     find one, falls back on statistics. Random outcomes of the condition are thus detrimental to performance as its    guess will be wrong at least half the time.</li> </ol>"},{"location":"chapter-2/#simd-vectorisation","title":"SIMD vectorisation","text":"<p>Scalar arithemetic, e.g. the addition, in CPUs operates as follows: the two operands are loaded in two (scalar)  registers, the add instruction will add them and put the result in a third register. </p> <p></p> <p>In modern CPUs the registers have been widened to contain more than one operand and the corresponding vector  addition can compute and store the result in the same number of cycles. Typically, a vector register is now 512 bits wide, or 64 bytes, the same as the lenght of a cache line.</p> <p></p> <p>SIMD vectorisation can in principle speed up loops by a factor of 2, 4, 8, 16, depending on the number of bytes the  data elements use. Howecer, when the data being processed is not in the cache it does not help. </p> <p>Tip</p> <p>If your code does not vectorize, first find out if the data is in the cache, If not is does not help. </p>"},{"location":"chapter-2/#the-cost-of-floating-point-instructions","title":"The cost of floating point instructions","text":"<p>Note</p> <p>All animals are equal, but some animals are more equal than others. Animal farm, George Orwell.</p> <p>Not all mathematical operations are equally fast. Here's a table listing their relative cost: </p> cost operations cheap addition, subtraction, multipication rather expeesive division expensive square root very expensive trigonometric, exponential, logarithmic functions <p>As an example, let's write a functon for the Lennard-Jones potential:</p> <p></p> <p>Here's a first C++ translation of the mathematical expression of the Lennard-jones potential:</p> <pre><code>double VLJ0( double r ) {\n    return 1./pow(r,12) - 1./pow(r,6);  \n} \n</code></pre> <p>We measured the cost of <code>VLJ0</code> by timing its application to a long array and express it relative to the best  implementation we could come up with. The cost of <code>VLJ0</code> is 18.0, so it is a really expensive implemenation. In view  of the table above, that should come to no surprise: it has two divisions and two <code>pow</code> calls which raise a real  number to a real power. <code>pow</code> is implemented using an exponential and a logarithm. Let's try to improve that.</p> <p>We can get rid of the divisions using : </p> <pre><code>function \ndouble VLJ1( double r ) {\n    return std::pow(r,-12) - std::pow(r,-6);\n}\n</code></pre> <p>This scores a bit better: 14.9, but the two <code>pow</code> calls remain expensive. The expression for the Lennard-Jones  potential can be rewritten as V(r)=r^{-6}(r^{-6}-1). Using a temporary to store r^{-6} we are left with only one  <code>pow</code> call: </p> <pre><code>double VLJ2( double r ) {\n    double tmp = std::pow(r,-6);\n    return tmp*(tmp-1.0);\n}\n</code></pre> <p>This has a performance score of 7.8, still far away from 1. Realizing that we don't need to use <code>pow</code> because the  expression has in fact integer powers,</p> <pre><code>double VLJ3( double r ) {\n    double tmp = 1.0/(r*r*r*r*r*r);\n    return tmp*(tmp-1.0);\n}\n</code></pre> <p>This has one division, 6 multiplications and subtraction. We can still reduce the number of multiplications a bit:</p> <pre><code>double VLJ( Real_t r ) {\n    double rr = 1./r;\n    rr *= rr;\n    double rr6 = rr*rr*rr;\n    return rr6*(rr6-1);\n}\n</code></pre> <p>Both these implementation have a performance score of 1. The optimum has been reached. The effect of two  multiplications less in the last implementation doesn't show, because in fact the compiler optimizes them away anyway. </p> <p>Note</p> <p>Compilers are smart, but it will not do the math for you. </p> <p>There is yet a common sense optimisation that can be applied. The standard formulation of the Lennard-Jones  potential is expressed as a function of r. Since it has only even powers of we can as well express it as a  function of s=r^2:</p> <p>  V_2(s) = 1/s^3(1/s^3 - 1)  </p> <p>At first sight, this may not immediately seem an optimisation, but in Molecular Dynamics the Lennard-Jones potential is  embedded in a loop over all interacting pairs for which distance between the interacting atoms is computed:</p> <pre><code>double interaction_energy = 0;\nfor(int i=0; i&lt;n_atosm; ++i)\n    std::vector&lt;int&gt;&amp; verlet_list_i = get_verlet_list(i); \n    for(int j : verlet_list_i) {\n        r_ij = std::sqrt( (x[j] - x[i])^2 + (y[j] - y[i])^2 + (z[j] - z[i])^2 )\n        if( r_ij &lt; r_cutoff)\n            interaction_energy += VLJ(r_ij);\n    }\n</code></pre> <p>Using V_2 this loop can be implemented as: </p> <pre><code>double interaction_energy = 0;\ndouble r2_cutoff = r_cutoff^2;\nfor(int i=0; i&lt;n_atosm; ++i)\n    std::vector&lt;int&gt;&amp; verlet_list_i = get_verlet_list(i); \n    for(int j : verlet_list_i) {\n        s_ij = (x[j] - x[i])^2 + (y[j] - y[i])^2 + (z[j] - z[i])^2\n        if( s_ij &lt; r2_cutoff)\n            interaction_energy += V_2(s_ij);\n    }\n</code></pre> <p>This avoid the evaluation of a <code>sqrt</code> for every interacting pair of atoms. </p> <p>Homework</p> <p>Write a program in C++ or Fortran to time the above implementations of the Lennard-Jones potential. Since  timers are not accurate enough to measure a single call, apply it to an array and divide the time for  processing the array by the number of array elements.</p> <ul> <li>Think about the length of the array in relation to the size of the cache (L1/L2/L3).</li> <li>Think about vectorisation. </li> </ul>"},{"location":"chapter-2/#consequences-of-computer-architecture-for-performance","title":"Consequences of computer architecture for performance","text":""},{"location":"chapter-2/#recommendations-for-array-processing","title":"Recommendations for array processing","text":"<p>The hierarchical organisation of computer memory has also important consequences for the layout of data arrays and  for loops over arrays in terms of performance (see below). </p> <ol> <li>Loops should be long. Typically, at the begin and end of the loop thee pipeline is not full. When the loop     is long, these sections can be amortized with respect to the inner section, where the pipeline is full. </li> <li>Branches in loops should be predictable. The outcome of unpredictable branches will be guessed wrongly,     causing pipeline stalls. Sometimes it may be worthwile to sort the array according to the probability of the     outcome if this work can be amortized over many loops.</li> <li>Loops should access data contiguously and with unit stride. This assures that<ul> <li>at the next iteration of the loop the data element needed is already in the L1 Cache and can be accessed    without delay,</li> <li>vector registers can be filled efficiently because they need contiguous elements from the input array.</li> </ul> </li> <li>Loops should have high computatonal intensity. The computational intensity I_c is defined as  I_c =     \\frac {n_{cc}}{n_{rw}} , with n_{cc} the number of compute cycles and n_{rw} the total number of bytes read and     written. A high computational intensity means many compute cycles and little data traffic to/from memory and thus     implies that there will be no pipeline due to waiting for data to arrive. This is a compute bound loop. Low     computational intensity, on the other hand, will cause many pipeline stalls by waiting for data. This is a     memory bound loop. Here, it is the bandwidth (the speed at which data can be transported from main memory     to the registers) that is the culprit, rather than the latency. </li> </ol>"},{"location":"chapter-2/#recommendations-for-data-structures","title":"Recommendations for data structures","text":"<p>The unit stride for loops recommendation translates into a recommendation for data structures. Let's take Molecular  Dynamics as an example. Object Oriented Programming (OOP) would propose a Atom class with properties for mass m,  position \\textbf{r}, velocity \\textbf{v}, acceleration \\textbf{a}, and possibly others as well, but let's  ignore those for the time being. Next, the object oriented programmer would create an array of Atoms. This approach  is called an array of structures (AoS). The AoS approach  leads to a data layout in memory like | m_0, r_{x0}, r_{y0}, r_{z0}, v_{x0}, v_{y0}, v_{z0}, a_{x0}, | a_{y0}, a_{z0}, m_1, r_{x1}, r_{y1}, r_{z1}, v_{x1}, v_{y1}, | v_{z1}, a_{x1}, a_{y1}, a_{z1} , m_2, r_{x2}, r_{y2}, r_{z2}, | v_{x2}, v_{y2}, v_{z2}, a_{x2}, a_{y2}, a_{z2}, ... Assume we  store the properties as single precision floating point numbers, hence a cache line spans 8 values. We marked the cache  line boundaries in the list above with vertical bars. Suppose for some reason we need to find all atoms j for  which r_{xj} is between x_{lwr} and x_{upr}. A loop over all atoms j would test r_{xj} and remember the  j for which the test holds. Note that every cache line contains at most one single data item that we need in this  algorithm. some cache lines will even contain no data items that we need. For every data iten we need, a new cache  line must be loaded. This is terribly inefficient. There is a lot of data traffic, only 1/8 of which is useful and the  bandwidth will saturate quickly. Vectorisation would be completely useless. To fill the vector register we would  need 8 cache lines, most of which would correspond to cache misses and cost hundreds of cycles, before we can do 8  comparisons at once. The AoS, while intuitively very attractive, is clearly a disaster as it comes to performance.  The - much better - alternative data structure is the SoA, structure of Arrays. This creates an AtomContainer  class (to stay in the terminology of Object Oriented progrmming) containing an array of length n_{atoms} for each  property. In this case there would be arrays for m, r_x, r_y, r_z, v_x, v_y, v_z, a_x, a_y, a_z.  Now all r_x are stored contiguously in memory and every item in a cache would be used. Only one cache line would  be needed to fill a vector register. Prefetching would do a perfect job. The SoA data structure is much more  efficient, and once you get used to it, almost equally intuitive from an OOP viewpoint. Sometimes there is  discussion about storing the coordinates of a vector, e.g. \\textbf{r} as per-coordinate arrays, as above, or as an  array of vectors. The latter makes is more practical to define vector functions like magnitude, distance, dot and  vector products, ... but they make it harder to SIMD vectorise those functions efficiently, because contiguous data  items need to be moved into different vector registers.  </p>"},{"location":"chapter-2/#selecting-algorithms-based-on-computational-complexity","title":"Selecting algorithms based on computational complexity","text":"<p>The computational complexity of an algorithm is an indication of how the number of instructions in an algorithms  scales with the problem size N. E.g. the work of an O(N^2) algorithm scales quadratically with its problem size.  As an example consider brute force neighbour detection (Verlet list construction) of N interacting atoms in Molecular  Dynamics:</p> <pre><code>    // C++ \n    for (int i=0; i&lt;N; ++i)\n        for (int j=i+1; j&lt;N; ++j) {\n            r2ij = squared_distance(i,j);\n            if (r2ij&lt;r2cutoff) \n               add_to_Verlet_list(i,j); \n        }\n</code></pre> <p>Note</p> <p>Note that we have avoided the computation of the square root by using the squared distance rather than the  distance.</p> <p>The body of the inner for loop is executed N*(N-1)/2 = N^2/2 -N/2 times. Hence, it is O(N^2). Cell-based Verlet  list construction restricts the inner loop to the surrounding cells of atom <code>i</code> and is therefor O(N).</p> <p>The computational complexity of an algorithm used to be a good criterion for algorithm selection: less work means  faster, not? Due to the workings of the hierarchical memory of modern computers the answer is not so clear-cut.  Consider two search algorithms for finding an element in a sorted array, linear search and binary search bisecting. Linear search simply loops over all elements until the element is found (or a larger element is found), and is thus  O(N). Binary search compares the target value to the  middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the  search continues on the remaining half, again taking the middle element to compare to the target value, and  repeating this until the target value is found. If the search ends with the remaining half being empty, the target  is not in the array. The complexity of this algorithm is O(log{N}). Clearly, binary search finds the answer  by visiting far fewer elements in the array as indicated by its lower complexity. However, contrary to linear search it  visits the elements in the array non-contiguously, and it is very well possible that there will be a cache miss on  every access. Linear search, on the other hand, will have no cache misses: it loads a cache line, visits all the  elements in it and in the mean time the prefetching machinery takes care of loading the next cache line. It is only  limited by the bandwidth. For small arrays linear search will be faster than binary search. For large arrays the  situation is reversed. A clever approach would be to combine both methods: start with binary search and switch to  linear search as soon as the part of the array to search is small enough. This needs some tuning to find the N at  which both algorithms perform equally well. The combined algorithm is thus not cache-oblivious. </p> <p>Tip</p> <p>There is no silver bullet. All approaches have advantages and disadvantages, some may appear in this situation  and others in another situation. The only valid reasoning is: numbers tell the tale (meten is weten):  measure the performance of your code. Measure it twice, then measure again.</p>"},{"location":"chapter-2/#supercomputer-architecture","title":"Supercomputer architecture","text":"<p>Note</p> <p>For a gentle but more detailed introduction about supercomputer architecture check out [this VSC course] (https://calcua. uantwerpen.be/courses/supercomputers-for-starters/Hardware-20221013-handouts.pdf). An updated  version will appear soon here  (look for 'Supercomputers for starters').</p> <p>We haven't talked about supercomputer architecture so far. In fact, supercomputers are not so very different from  ordinary computers. The basic building block of a supercomputer is a compute node, or a node tout court.  It can be seen as an ordinary computer but without peripheral devices (no screen, no keyboard, no mouse, ...).  A supercomputer consists of 100s to 1 000s of nodes (totalling up to 100 000s of cores), mutually connected to an  ultra-fast network, the interconnect. The interconnect allows the nodes to exchange information so that they can  work together on the same computational problem. It is the number of nodes and cores that makes a supercomputer a  supercomputer, not (!) the performance of the individual cores. Motherboards for supercomputer nodes typically have  2 sockets, each of which holds a CPU. Technically speaking they behave as a single CPU double the size, and double  the memory. Performance-wise, however, the latency across the two CPUs is typically a factor 2 larger. This goes by  the name ccNUMA, or cache coherent non-uniform memory architecture. Cache coherence means that if caches  of different copies hold copies of the same cache line, and one of them is modified, all copies are updated.  NUMA means that there are different domains in the global address space of the node with different latency and/or  bandwidth. CPU0 can access data in DRAM1, but this is significantly slower (typically 2x). </p> <p></p>"},{"location":"chapter-3/","title":"Chapter 3 - Optimise first, then parallelize","text":""},{"location":"chapter-3/#when-to-parallelize-and-what-to-do-first","title":"When to parallelize, and what to do first...","text":"<p>When your program takes too long, the memory of your machine is too small for your problem or the accuracy you need  cannot be met, you're hitting the wall. Parallelization seems necessary, and you feel in need of a supercomputer. However, supercomputers are expensive machines and resources are limited. It should come to no surprise that it is  expected that programs are allowed to run on supercomputers only if they make efficient use of their resources.  Often, serial programs provide possibilities to improve the performance. These come in two categories: common sense  optimisations (often completely overlooked by researchers) which rely on a good understanding of the mathematical  formulation of the problem and the algorithm, and code optimisations which rely on understanding processor  architecture and compilers. Lets first look at common sense optimisations. </p>"},{"location":"chapter-3/#common-sense-optimisations","title":"Common sense optimisations","text":"<p>Common sense optimizations come from a good understanding of the mathematical formulation of the problem and seeing  opportunities to reduce the amount of work. We give three examples. </p>"},{"location":"chapter-3/#1-magnetization-of-bulk-ferromagnets","title":"1. Magnetization of bulk ferromagnets","text":"<p>I was asked to speed up a program for computing the magnetisation  of bulk ferromagnets as a function of  temperature T. This is given by a self-consistent solution of the equations:</p> <p>  m = \\frac{1}{2 + 4\\Phi(m)}  </p> <p>  \\Phi(m) = \\frac{1}{N} \\sum_{\\textbf{k}} \\frac{1}{e^{\\beta\\eta(\\textbf{k})m} - 1}  </p> <p>with  \\beta = 1/{k_B T} . At T=0 we have m(0) = m_0 = 0.5, and at high T, m(T) approaches zero.</p> <p>The solution is a curve like this:</p> <p></p> <p>The program compute this as follows: For any temperature T, set m = m_0 as an inital guess. Then iterate  m_ {i+1} = 1/(2 + 4\\Phi(m_i))  until  \\Delta m = m_{i+1} - m_i  is small. Here,</p> <p>  \\Phi(m) = \\sum_{n=1}^\\infty \\frac{a}{\\pi} \\left(\\int_0^{\\pi/a} dq e^{-nm\\beta\\eta_1(q)}\\right)^3  </p> <p>and the integral is computed using Gauss-Legendre integration on 64 points.  </p> <p>The choice of m=0.5 as initial guess is obviously a good one close to T=0. However, looking at the graph above,  it becomes clear that as T increases the solution moves further and further away from 0.5. Furthermore, if we  compute tempurature points at equidistant tempurature points, T_j = \\delta j for some \\delta and j=0,1,2, . .., it is also clear that the solution of the previous temperature point, i.e. m_{j-1}, is a far better initial  initial guess  guess than m_0. This turns out to be 1.4x faster. Not a tremendous improvement, but as the graph above seems  continuous w e can take this idea a step further: using interpolation from solutions a lower temperature points to  predict the next solution and use that as an initial guess. Linear interpolation of m_j from m_{j-1} and  m_{j-2} gives a speedup of 1.94x and quadratic interpolation from m_{j-1}, m_{j-2} and m_{j-3} a factor of 2.4x. That is a substantial speedup achieved without acttually modifying the code. This optimisation comes entirely from  understanding what your algorithm actually does. Investigation of the code itself demonstrated that it made suffered  from a lot of dynamic memory management and that it did not vectorize. After fixing these issues, the code ran an  additional 13.6x faster. In total the code was sped up by an impressive 32.6x.</p>"},{"location":"chapter-3/#2-transforming-the-problem-domain","title":"2. Transforming the problem domain","text":"<p>At another occasion I had to investigate a code for calculating a complicated sum of integrals in real space. After  fixing some bugs and some optimisation to improve the efficiency, it was still rather slow because the formula  converged slowly  As the code was running almost at peak performance, so there was little room for improvement.  However, at some point we tried to apply the Fourier transform to get an expression in frequency space. This  expression turned out to converge much faster and consequently far less terms had to be computed, yielding a speedup  of almost 2 orders of magnitude and was much more accurate. This is another example of common sense optimisation  originating in a good mathematical background. The natural formulation of a problem is not necessarily the best to  use for computation.    </p>"},{"location":"chapter-3/#3-transforming-data-to-reduce-their-memory-footprint","title":"3. Transforming data to reduce their memory footprint","text":"<p>I recently reviewed a Python code by the Vlaamse Milieumaatschappij for modelling the migration of invertebrate aquatic  species in response to improving (or deteriorating) water quality. The program read a lot data from .csv files. For  a project it was necessary to run a parameter optimisation. That is a procedure where model parameters are varied  until the outcome is satisfactory. If the number of model parameters is large the number of program runs required can  easily reach in the 100 000s. The program was parallellized on a single node. However, the program was using that many  data that 18 cores of the 128 cores available on a node already consumed all the available memory. By replacing the  data types of the columns of the datasets with datatypes with a smaller footprint, such as replacing categorical data  with integer IDs, replacing 32-bit integers with 16-bit or even 8-bit integers, float64 real numbers with float32 or  float16 numbers reduced the amount of data used by a factor 8. All of a sudden much more cores could be engaged in  the computation and the simulation sped up considerably.   </p> <p>Some of these \"common sense optimisations\" may seem obvious. Yet, of all the codes I reviewed during my career, few  of them were immune to common sense optimisation. Perhaps, developing (scientific) software takes a special mindset: </p> <p>Tip</p> <p>The scientific software developer mindset: Constantly ask yourself 'How can I improve this? How can I make  it faster, leaner, more readable, more flexible, more reusable, ... ?'</p> <p>Common sense optimisations are optimisations that in general don't require complex code analysis, require very little  code changes and thus little effort to implement them. Yet they can make a significant contribution.</p>"},{"location":"chapter-3/#code-optimisations","title":"Code optimisations","text":"<p>Code optimisations are optimisations aiming at making your solution method run as efficient as possible on the  machine(s) that you have at your disposal. This is sometimes referred as code modernisation, because code that  was optimised for the CPUs of two years a go may well need some revision for the latest CPU technology. These  optimisations must, necessarily, take in account the specific processor architecture of your machine(s). Important  topics are: </p> <ul> <li>Avoid pipeline stalls (due to impredictable branches, e.g.) </li> <li>Ensure SIMD vectorisation. On modern processors vector registers can contain 4 double precision floating point    numbers or 8 single precision numbers and vector instructions operate on these in the same number of cycles as    scalar instructions. Failing to vectorise can reduce the speed of your program by a factor up to 8x!   </li> <li>Smart data access patterns are indispensable for programs with a memory footprint that exceeds the size of the cache.    Transferring data from main memory (DRAM) to the processor's registers is slow: typical latencies are in the order    of 100 cycles (which potentially wastes ~800 single precision vectorised operations). Vector instructions are of    no help if the processing unit must wait for the data. </li> </ul> <p>This is clearly much more technical and complicated (in the sense that it requires knowledge from outside the  scientific domain of the problem you are trying to solve). Especially fixing memory access patterns can be difficult  and a lot ofwork, as you may have to change the data structures used by your program, which usually also means  rewriting a lot of code accessing the data. Such code optimisations can contribute significantly to the performance  of a program, typically around 5-10x, but possibly more. As supercomputers are expensive research infrastructure in  high demand, we cannot effort to waste resources. That being said, the lifetime of your program is also of  importance. If you are developing a code that will be run a few times during your Master project or PhD, using only  a hundred of node days, and to be forgotten afterwards, it is perhaps not worth to spend 3 months optimising it.</p> <p>Often, however, there is a way around these technicalities. If the scientific problem you are trying to solve, can  be expressed in the formalism of common mathematical domains, e.g. linear algebra, Fourier analysis, ..., there is  a good chance that there are good software libraries, designed with HPC in mind, that solved these problems for you.  In most cases there are even bindings available for your favorite progamming language (C/C++, Fortran, Python, ...). All you have to do is translate the mathematical formulation of your problem into library calls. </p> <p>Tip</p> <p>Use HPC libraries as much as possible. There is little chance that you will outperform them. Quite to the  contrary: your own code will probably do significantly worse. By using HPC libraries you gain three times:</p> <ul> <li>you gain performance,</li> <li>you gain development time as you will need a lot less code to solve your problem, less debugging, simpler    maintenance, ...</li> <li>your learn how to use the library which will get you at speed readily when you take on your next    scientific problem.</li> </ul> <p>Tip</p> <p>Don't reinvent the wheel. The wheel was invented ~8000 years ago. Many very clever people have put effort in  it and is pretty perfect by now. Reinventing it will unlikely result in an improvement. By extension: if you  need some code, spend some time google-ing around to learn what is already available and how other researchers  attack the problem. It can save you weeks of programming and debugging. Adapting someone else's code to your  needs will learn you more than coding it from scratch. You'll discover other approaches to coding problems than  yours, other language constructs, idioms, dependencies to build on, learn to read someone else's code, learn to  integrate pieces.    </p>"},{"location":"chapter-3/#when-is-code-optimized-enough","title":"When is code optimized enough?","text":"<p>Tip</p> <p>Premature optimization is the root of all evil Donald Knuth. </p> <p>This quote by a famous computer scientist in 1974 is often used to argue that you should only optimize if there is a  real need. If code is too slow, measurements (profiling) should tell in which part of the code most time is  spent. That part needs optimision. Iterate this a few times. Blind optimisation leads to useless and developer time  wasting micro-optimisations rendering the code hard to read and maintain. On the other hand, if we are writing code  for a supercomputer, it better be super-efficient. But even then, depending on the lifetime of the program we are  writing, there is a point at which the efforts spent optimising are outweighed by having to wait for the program  going in production.</p> <p>How can one judge wether a code needs further optimization or not? Obviously, there are no tricks for exposing  opportunities for common sense optimisations, nor for knowing wether better algorithms exist. That is domain  knowledgs, it comes with experience, and requires a lot of background. But for a given code and given input, can we  know wether improvements are possible? In Chapter 1 we mentioned the existence of  machine limits, the peak performance, P_p, the maximum number of floating point operstions that can be executed per  second, and the bandwidth, B, the maximum number of bytes that can be moved between main memory and the CPU's  registers per second. It is instructive to study how these machine limits govern the maximum performance P_{max}  as a function of the computational intensity I_c. If the CPU must not wait for data, P_{max} = P_p. In the  situation where the bandwidth is limiting the computation  P_{max} = BI_c. This leads to the formula: </p> <p>  P_{max} = min(P_p,BI_c)  </p> <p>This is called the roofling model, since its graph looks like a roofliine.</p> <p></p> <p>We can measure the actual performance and computational intensity of the program and plot it on the graph. The point  must necessarily be under the roofline. For a micro-benchmark, such as a loop with a simple body, we can compute  I_c by hand, count the Flops and time the benchmark to obtain the computational intensity. For an entire program  a performance analysis tool can construct the graph and measure where the program is in the graph. Let's discuss 4  different cases, corresponding to the four numbered spots in the graph above.</p> <ol> <li>Point 1 lies in the bandwidth limited region, but well below the roofline. Something prevents the program to go     at the maximum performance. There can be many causes: bad memory access causing cache misses, the code may fail     to vectorize, pipeline stalls, ... for a micro-benchmark you can perhaps spot the cause without help. For a     larger program a performance analyzer will highlight the problems. </li> <li>Point 2 lies in the peak performance limited region, also well below the roofline. Hence, cache misses are     unlikely the cause. </li> <li>Point 3 lies close to the roofline and the boundary between the bandwidth limited region and the peak performance     limited region. This the sweet spot. Both peak performance and bandwith are fully used.</li> <li>Point 4 lies close to the roofline in the peak performance limited region. This is an energy-efficient     computation at peak performance. It moves little data (high I_c). Moving data is by far the most energy     consuming part in a computation.</li> </ol>"},{"location":"chapter-3/#common-approaches-towards-parallelization","title":"Common approaches towards parallelization","text":"<p>Before we discuss common parallelization approaches, we need to explain some concepts:</p> <ul> <li> <p>process (wikipedia): \"In computing, a process is the    instance of a computer program that is being executed by one or more threads.\" A process has its own address    space, the region of main memory that can be addressed by the process. Normally, a process cannot go outside its    address space, nor can any other process go inside the process's own address space. An exception is when both    processes agree to communicate, which is the basis of distributed memory parallelism (see below). In general, a    process is restricted to a single node, and the maximum number of parallel threads is equal to the number of cores    on that node. </p> </li> <li> <p>thread (wikipedia): \"In computer science, a thread of    execution is the smallest sequence of programmed instructions that can be managed ...\". The instructions in a    thread are thus by definition sequential. In the context of parallel computing, parallel threads are managed by the    parent process to run different tasks in parallel. Obviously, parallel threads need to run on distinct cores to be    truely concurrent. As threads belong to a process, they can in principle have access to the entire address space of    the process. Sometimes a distinction is made between hardware threads and software threads. A software thread    is a set of sequential instructions for a computational task that is scheduled by the program to execute. When its    execution starts, it is assigned to a core. software threads can be interrupted, in order to let the core do other,    more urgent work, e.g., and restarted. There can be many more software threads in a program than it has cores    available, but, obviously, they cannot all run in parallel. Software threads arre very useful in personal    computers with many interactive applications opened simultaneously, where are many non-urgent tasks. For HPC    applications they are a bit heavy weight. A hardware thread is a lightweight software thread that is    exclusively tied to a core. When given work, it can start immediately and runs to completion without interruption.    That is certainly useful in HPC where not loosing compute cycles is more important than flexibility.</p> </li> </ul> <p>Now that we understand the concepts of processes and threads, we can explain three different types of  parallelization:</p>"},{"location":"chapter-3/#shared-memory-parallelization","title":"Shared memory parallelization","text":"<p>In shared memory parallelization there is one process managing a number of threads to do work in parallel. As all  the threads belong to the same process, they have access to the entire memory address space, that is, they  share memory. To avoid problems, as well as for performance reasons, the variables inside a thread are private by  default, i.e. they can only be accessed by the thread itself, and must be declare shared if other threads should  have access too. Cooperating threads must exchange information by reading and writing to shared variables. </p> <p>The fact that all the threads belong to the same process, implies that shared memory programs are limited to a single  node, because a process cannot span several nodes. However, there exist shared memory machines larger than a typical  supercomputer node, e.g. SuperDome at KU leuven. Such systems allow to run a shared memory program with much more threads and much more memory.  This approach can be useful when distributed memory parallelization is not feasible for some reason. </p> <p>The most common framework for shared memory parallelization is OpenMP. OpenMP  parallelization of a sequential program is relatively simple, requiring little changes to the source code in the form of directives. A good starting point for OpenMP parallelization is this video. An important limitation of OpenMP is that it is only available in C/C++/Fortran, and not Python.  Fortunately, Python has other options, e.g. multiprocessing, concurrent.futures and dask. In addition it is possible to build your own Python modules from C++ or Fortran code, in which OpenMP is used  to parallelize some tasks. The popular numpy is a good example.</p>"},{"location":"chapter-3/#pgas","title":"PGAS","text":"<p>PGAS, or Partitioned Global Address Space,  is a parallel programming paradigm that provide communication operations involving a global memory address space on  top of an otherwise distributed memory system.  </p>"},{"location":"chapter-3/#distributed-memory-parallelization","title":"Distributed memory parallelization","text":"<p>Distributed memory parallelization is the opposite of shared memory parallelization. There are many process,  each with only a single-thread. Every process has its own memory address space. These address spaces are not shared,  they are distributed. Therefor, explicity communication is necessary to exchange information. For processes on the  same machine (=node) this communication is intra-node, but for processes on distinct machines messages are sent  over the interconnect.</p> <p>Distributed memory programs are considerably more complex to write, as the communication must be explicitly handled  by the programmer, but may use as many processes as you want. Transformation of a sequential program into a  distributed memory program is often a big programming effort. The most common framework is MPI . MPI is available in C/C++/Fortran and also in Python by the mpi4py  module. </p>"},{"location":"chapter-3/#hybrid-memory-parallelization","title":"Hybrid memory parallelization","text":"<p>Hybrid memory parallelization combines both approaches. It has an unlimited number of processes, and a number of  threads per process, which run in parallel in a shared memory approach (OpenMP). The process communicate with each  other using MPI. Typically, the computation is organised as one proces per NUMA domain and one thread per core in  dat NUMA domain.  </p> <p>This approach uses shared memory parallelization where it is useful (on a NUMA domain), but removes the limitation  to a single machine. It has less processes, and thus less overhead in terms of memory footprint, and  communication overhead. It is also a bit more complex that pure distributed memory parallelization, and much more  complex than shared memory parallelization.</p> <p>Hybrid memoryy parallelization is usually implemented with OpenMP at the shared memory level and MPI at the  distributed level.</p>"},{"location":"chapter-4/","title":"chapter 4 - Case studies","text":""},{"location":"chapter-4/#monte-carlo-ground-state-energy-calculation-of-a-small-atom-cluster","title":"Monte Carlo ground state energy calculation of a small atom cluster","text":""},{"location":"chapter-4/#introduction","title":"Introduction","text":"<p>The code for this benchmark was Kindly provided by Jesus Eduardo Galvan Moya, former PhD student of the Physics  Department, Condensed Matter Theory.</p> <p>It is a small molecular dynamics code which happens to serve many didactical purposes. It is simple code, not too big. Full of issues you should learn to pay attention to ;-)</p> <p>The goal of the program is to calculate the ground state energy of a small atomistic system of 10-150 atoms. The  system is at 0K, so there are no velocities, and the total energy of the system consist of the interaction energy  only. Interactions are described by a pair-wise interaction potential, without cutoff radius (brute force).  A Monte Carlo approach is used to find the configuration with the lowest energy, 1000 separate runs with different  initial configuration are run. Each run comprises 200 000 random atom moves. Finally, the run with the lowest energy is kept and subjected to Quasi-Newton iteration in order to find a  local energy minimum. </p>"},{"location":"chapter-4/#implementation","title":"Implementation","text":"<p>Here is how this algorithm goes (C++ pseudo code):   </p> <pre><code>n_atoms = 50; // (for example)\nstd::vector&lt;double&gt; x, y, z, xmin, ymin, zmin;\ndouble Emin = std::numeric_limits&lt;double&gt;::max();\nfor(int ic=0; ic&lt;1000; ++ic)\n{// loop over initial configurations\n // generate initial configuration\n    initialize(x,y,z);\n    for(int ip=0; ip&lt;200000; ++ip) \n    {// loop over random perturbations\n     // perturb the current configuration    \n        x += small_perturbation();\n        y += small_perturbation();\n        z += small_perturbation();\n        E = 0;\n     // double loop over all interactions\n        for(int i=0; i&lt;n_atoms; ++i)\n            for(int j=0; j&lt;i; ++j) {\n                double rij = std::sqrt((x[j]-x[j])^2 + (y[j]-y[j])^2 + (z[j]-z[j])^2);\n                E += V(rij);\n            }\n        }\n    }\n    if( E &lt; Emin )\n    {// remember the current (perturbed) configuration\n        xmin = x;\n        ymin = y;\n        zmin = z;\n        Emin = E\n    }\n} \n// Perform a Newton-Raphsom iteration on E(x,y,z) with x0 = xmin, y0 = ymin, z = zmin.   \n...\n</code></pre> <p>The memory footprint of this problem is (<code>n_atoms</code> x 3) <code>doubles</code> x 8 bytes/<code>double</code>. For <code>n_atoms = 150</code>, that is  3600 bytes, which is far less than the size of L1 cache (32KB). Hence, the problem fits easily in the L1 cache. As  soonas the entire problem is loaded in the cache, the code will run without needing to wait for data. Furthermore, the  interaction potential </p> <p> </p> <p>is rather compute intensive, as it uses several expensive operations: two exponentials and two divisions, plus the  square root for the distance which here cannot be avoided:</p> <p>  r = r_{ij}(r_i,r_j) = \\sqrt{(x_j-x_i)^2 + (y_j-y_i)^2 + (z_j-z_i)^2 }  </p> <p>Consequently, the code is certainly compute bound.</p>"},{"location":"chapter-4/#optimisation","title":"Optimisation","text":"<p>Most of the work is carried out in the inner double loop over the interactions. Let's see if we can optimise this. </p> <p>Initially, both expressions for the interatomic distance r_{ij}(r_i,r_j) and the interaction potential V(r) were implemented as functions called in the double loop. The first timing for the double loop with 50 atoms is 144  \\mus. By checking the vectorisation report of the compiler, we learned that the two function calls prohibited  vectorisation. After inlining the functions,  the timing was reduced to 93 \\mus. The inner loop contains a lot of short loops. This is bad for pipelining and vectorisation (many loops end with  incompletely filled vector registers.) If we split the loop in a double loop for calculating the interatomic  distances and storing them in a long array, and a long loop over that array to compute the interactions, the  situation might improve. </p> <pre><code>        E = 0;\n        int n_interactions = n_atoms*(n_atoms-1)/2;\n        std::vector&lt;double&gt; rij(n_interactions); \n         // (in C++ std::vector is actually a contiguous array)\n     // double loop over all interactions\n        for(int i=0; i&lt;n_atoms; ++i)\n            for(int j=0; j&lt;i; ++j) \n                rij = std::sqrt((x[j] - x[j])^2 + (y[j] - y[j])^2 + (z[j] - z[j])^2);\n        }\n        for(int ij=0; ij&lt;n_interactions; ++ij)\n            E += V(rij[ij]);\n</code></pre> <p>This reduces the time from 93 to 86 \\mus. Not much, but since we must runs this loop 1 000 x 200 000 times it  nevertheless represents a substantial gain. </p> <p>Note</p> <p>We implemented this both in C++ and Fortran. The results were almost identical. You sometimes hear that C++ is  an inefficient programming language and that the opposite holds for Fortran. This is not true. Both C++ and  Fortran compilers are capable to build optimally performant progams for the CPU at hand. We'll come to this  subject later. </p> <p>At this point, we seem to be done optimising the inner loops. Maybe there is something we can do to the  surrounding loops? The perturbation loop adds a small perturbation to every coordinate of every atom in the list to  see if the perturbation results in a lower energy. The perturbation involves 3n_{atoms} random numbers and  generation random numbers is also rather expensive. We might wonder if it is really necessary to perturb all atoms.  What if we perturbed only one atom? That reduces the number of random number generations by a factor n_{atoms}. In  addition, most of the interactions remain the same, only the n_{atoms}-1 interactions with the perturbed atom  change. Hence our program now has a complexity O(N). In the original formulation the number of interaction to be  computed was n_{atoms}(n_{atoms}-1)/2 = O(N^2). As the program is compute bound changing the computational  complexity  from O(N^2) to O(N) will have a big impact. This optimisation falls under the  common sense optimisations. </p> <p>It is important to realize that this optimisation changes the nature of the algorithm. It remains to be seen whether  200 000 configurations is still sufficient to find the minimum. We might need more, or maybe less. This up to  the researcher to investigate. </p> <p>Let's see how we can implement this modification and how that effects the performance. We start with depicting the  relation between $r_{ij}) as a (lower triangular) matrix and as the linear <code>rij</code> array in the split loop above. </p> <p></p> <p>The linear array stores the rows of the lower triangular matrix: [r_{10}, r_{20}, r_{21}, r_{30}, r_{31},  r_{32}, r_{40}, r_{41}, r_{42}, r_{43}, ... ]. The matrix elements show the value or the  index into the linear array. Let's do something similar for the interaction energy:</p> <p></p> <p>We have added a column to compute the row sums and the total sum of the interaction energies E_{ij}. Let's now  visualize the changes when an atom, say atom 4, is perturbed.</p> <p></p> <p>The items changing due to perturbing r_4 are marked in orange. The row sum for row 4 has to be computed from scratch and in row 5 and 6 the elements corresponding to column 4 change as well. The next figure shows how the perturbed  result can be computed from the previous result by first subtracting the previous result and then adding the new  result. </p> <p></p> <p>Here is a comparison of the timings:</p> N O(N^2) O(N) speedup 50 86 \\mus 5.7 15.1 150 (x3) 747 \\mus (x9) 17.3 \\mus (x3) 43.3 500 (x10) 8616 \\mus (x100) 57.0 \\mus (x10) 115.2 <p>Clearly, the timings for the O(N^2) algorithm increase quadratically, while those for the O(N) algorithm increase  only linearly and the speedups are substantial. The O(N) algorithm for 500 atoms - a number that our researcher  considered unattainable because it would take too long to compute - is still faster than the O(N) algorithm.</p> <p>Tip</p> <p>Look for algorithms of low computational complexity. However, The best algorithme may also depend on the  problem as we saw in Selecting algorithms based on computational complexity.  </p> <p>Despite the considerable performance improvement, there are a few disadvantages to it too. The O(N) algorithm has  more code, is more difficult to understand and thus harder to maintain. Morover, its loops are more complex, making  it harder for the compiler to optimize. Autovectorisation doesn't work. If it needs further optimization, it is  certainly no low-hanging fruit.   </p>"},{"location":"chapter-4/#parallelization","title":"Parallelization","text":"<p>If the time of solution for this sofar sequential program is still too large, we might opt for parallelization. The  interaction loop is now doing relatively little work, and hard to parallelize. On the other hand the perturbation  loop can be easily distributed over more threads as this loop is  embarrassingly parallel. As long as every thread generates a different series of  random numbers they can run their share of the perturbation iterations completely independent. This is very easy to  achieve with OpenMP. In the end every thread would have its own minimum energy configuration, and the overall  minimum energy configuration is simply found as the minimum of per thread minima. Since every core has its own L1  cache, the problem for each thread also fits in L1. </p>"},{"location":"chapter-4/#project-mcgse","title":"Project mcgse","text":"<p>The <code>wetppr/mcgse</code> folder repeats this case study for the Morse potential (I lost the original code :-( )</p> <p>  V(r) = D_e(1 - e^{-\\alpha(r-r_e)})^2  </p> <p>We will assume that all parameters are unity. </p> <p>  V(r) = (1 - e^{1-r)})^2  </p> <p>Here is its graph:</p> <p></p> <p>Using our research software devolopment strategy, we start in Python, implement both algorithms and  test. A good test is the case of a cluster of 4 atoms. Energy minimum then consists of a tetrahedron with unit sides. Every pair is then at equilibrium distance and E_{min}=0. The vertices of the tetrahedron are on a sphere of  radius \\sqrt{3/8}. Let us randomly distribute 4 points on a sphere of radius \\sqrt{3/8} and see how well close  we get to E_{min}=0. </p> <pre><code>    import numpy as np\n    import mcgse # our module for this project: wetppr/mcgse\n    sample = mcgse.sample_unit_sphere(4) * np.sqrt(3/8)\n    config = (sample[0], sample[1], sample[2]) # initial coordinates of the atoms (x,y,z)\n    dist = mcgse.LogNormal(mean=-5, sigma=.4) # distribution to draw the length of the displacements from\n    #   the distribution and its parameters were selected using quite some trial and error to obtain \n    #   useful results...\n    Emin_ON2, *config_min_ON2 = mcgse.execute_perturbation_loop(config=config, n_iterations=20000, dist=dist, algo='ON2', verbosity=1)\n    Emin_ON , *config_min_ON  = mcgse.execute_perturbation_loop(config=config, n_iterations=20000, dist=dist, algo='ON' , verbosity=1)\n</code></pre> <p>Here are the results for 5 runs:</p> <pre><code>ON2 iteration 0: Emin=1.8642580817361518\nON2 iteration 200000: Emin=0.343375960680797, last improvement: iteration = 2044\nON iteration 0: Emin=1.8642580817361518\nON iteration 200000: Emin=0.1318184548419835, last improvement: iteration = 30162\n\nON2 iteration 0: Emin=1.0114013021541974\nON2 iteration 200000: Emin=0.368488427516059, last improvement: iteration = 32701\nON iteration 0: Emin=1.0114013021541974\nON iteration 200000: Emin=0.058861153165589014, last improvement: iteration = 5168\n\nON2 iteration 0: Emin=3.69912617914294\nON2 iteration 200000: Emin=0.3819530373342961, last improvement: iteration = 4580\nON iteration 0: Emin=3.69912617914294\nON iteration 200000: Emin=0.3297933435887894, last improvement: iteration = 65216\n\nON2 iteration 0: Emin=3.299140128625619\nON2 iteration 200000: Emin=0.5323556068840862, last improvement: iteration = 12505\nON iteration 0: Emin=3.299140128625619\nON iteration 200000: Emin=0.5270227273967558, last improvement: iteration = 16929\n\nON2 iteration 0: Emin=1.2894488159651718\nON2 iteration 200000: Emin=0.40188231571036437, last improvement: iteration = 2621\nON iteration 0: Emin=1.2894488159651718\nON iteration 200000: Emin=0.07936811573814093, last improvement: iteration = 25806\n</code></pre> <p>We can draw some interesting observations from these runs:</p> <ul> <li>Neither of the algorithms seem to get close to the minimum,</li> <li>In terms of closeness to the minimum there no clear winner, although <code>ON</code> got rather close twice,</li> <li>The higher the initial energy, the worse the solution, which is acceptable, as the average displacement magnitude    is fixed.</li> <li>None of the algorithms seems to converge. In the first and the last run <code>ON2</code> found its best guess at 2044 and    2621 iterations. None of the approximately 198_000 later attempts could reduce the energy. This seems to be the    case for <code>ON</code> as well, although the numbers are a bit higher. Despite being far from the minimum, improvements    seem to involve progressively more work. </li> </ul> <p>Especially the last conclusion is rather worrying. Our algorithms don't seem to sample the configuration space very  efficiently. </p> <p>Perhaps, rather than displacing the atoms randomly, it might be more efficient to move them in the direction of the  steepest descent of the energy surface. Since we have an analytical expression, we can compute it. The interaction  V(r_{ij}) exerts a force </p> <p>  {\\mathbf{F}}_k = -\\nabla_{\\mathbf{r}_k}E  </p> <p>  = -\\nabla_{\\mathbf{r}_k} \\sum_{i&lt;j}V(r_{ij}) = -\\sum_{i&lt;j} \\nabla_{\\mathbf{r}_k}V(r_{ij}) </p> <p> = -\\sum_{i&lt;j} \\frac{d}{d_{r_{ij}}}V(r_{ij})\\nabla_{\\mathbf{r}_k}r_{ij} = -\\sum_{i&lt;j} V'(r_{ij})\\nabla_{\\mathbf{r}_k}r_{ij} </p> <p>Here, </p> <p> \\nabla_{\\mathbf{r}_k}r_{ij} = 0 \\text{  if  } k \\ne i,j  </p> <p>and</p> <p> \\nabla_{\\mathbf{r}_k}r_{kj} = -\\frac{\\mathbf{r}_{kj}}{r_{kj}} = -{\\hat{\\mathbf{r}}}_{kj} </p> <p> \\nabla_{\\mathbf{r}_k}r_{jk} = \\frac{\\mathbf{r}_{jk}}{r_{jk}} = {\\hat{\\mathbf{r}}}_{jk} </p> <p>Thus, </p> <p>Hence:</p> <p>  \\mathbf{F}_k = \\sum_{j\\ne{k}} V'(r_{kj}){\\hat{\\mathbf{r}}}_{kj} = -\\sum_{j&lt;k} V'(r_{jk}){\\hat{\\mathbf{r}}}_{jk}  + \\sum_{k&lt;j} V'(r_{kj}){\\hat{\\mathbf{r}}}_{kj} </p> <p>Finally (setting all parameters to unity),  </p> <p>  V'(r) = -2(1-e^{1-r})e^{1-r} </p> <p>Now that we have the forces on the atoms in the current configuration, we should be able to move the atoms in the  directon of the force, rather than in a random direction, as before. In fact we have a true minimisation problem now.</p> <p>to be continued...</p>"},{"location":"chapter-4/#study-of-data-access-patterns-in-a-large-lennard-jones-systems","title":"Study of data access patterns in a large Lennard-Jones systems","text":""},{"location":"chapter-4/#introduction_1","title":"Introduction","text":"<p>In this case study we consider a large system of atoms whose interaction is described by a Lennard-Jones potential.  By large we mean a system that does not fit in the cache. Consequently, the effect of caches will be noticabel in  the results. We will consider two different settings. A Monte Carlo setting, as above, in which the interaction  energy is computed as a sum of pairwise interactions. It is of little physical significance, but is useful to  demonstrate the effect of the caches on the computations. </p> <p>The second setting is a true molecular dynamics setting in which the time evolution of a collection of atoms is  computed by time integration of the interaction forces which are computed as the gradient of the interaction potential. This gives rise to time dependent accelerations, velocities and positions of the atoms. </p>"},{"location":"chapter-4/#monte-carlo-setting","title":"Monte Carlo setting","text":"<p>The interaction energy is given by:</p> <p>  E=\\sum_{i&lt;j}V(r_{ij})  </p> <p>Since our sytem is large, say billions of atoms, computing this sum considering all pairs, is computationally  unfeasible because it has O(N^2) computational complexity. We will discuss approaches to reduce the computational  complexity to O(N). To study the effect of the cache we will compute the partial sum  </p> <p>  E_i=\\sum_{j\\ne{i}}V(r_{ij})  </p> <p>for i=0, that is </p> <p>  E_0=\\sum_{j=1}^{N}V(r_{0j})  </p> <p>Because our system is translationally invariant, we can put atom 0 at the origin, in which case r_{0j}=r_j.  Thus, we end up with:</p> <p>  E_0=\\sum_{j=1}^{N}V(r_{j})  </p> <p>We will use the best implementation for the Lennard-Jones potential that we discussed in  The cost of floating point instructions, expressed as a function of r^2, as to avoid the square root needed to compute r. We consider three different cases:</p> <ol> <li>A contiguous loop over arrays <code>x[1:N]</code>, <code>y[1:N]</code>, <code>z[1:N]</code>. This is a structure of arrays (SoA) approach.</li> <li>A contiguous loop over a single array <code>xyz[1:3N</code>, in which the x, y and z coordinates of the i-th     atom come after each other followed by the  x, y and z coordinates of the i+1-th atom. This is a array of     structures approach (AoS).</li> <li>A contiguous loop over arrays <code>x[1:N]</code>, <code>y[1:N]</code>, <code>z[1:N]</code> in which the atoms are picked by random permutation of     1..N. So, all atoms are visited, but in a random order. </li> </ol> <p>For each case  E_0=\\sum_{j=1}^{N}V(r_{j})  is computed for N \\in \\{2^9,2^10,2^11,...,2^{29}\\} repeating the loop  over j 2^{29}/N times. In this way the amount of interaction potential evaluations is exactly 2^{29}  irrespective of the length of the array, and the timings can be compared. The smallest arrays fit in L1, while the  longest arrays (2^29\\approx0.5\\times10^9) do not even fit in L3. Here are the timings:</p> <p></p> <p>It is clearly visible that the behaviour of the random case above is very different from the two contiguous cases.  For the longest arrays, the performance is a whopping 15x worse on the random loop, yet every case performs exactly  the same work. There burning question is of course: \"what is causing the performance breakdown of the randomized  loop\"? The second question, certainly less burning, but nevertheless important, is: \"is the lowest curve (the AoS  case) the best we can get?\". If you are really curious, you might wonder about the small difference between the AoS  case and the SoA case at larger N. To help your understanding of the problem, here is a different representation  of the same graph, this time the number of bytes used by the arrays on the x-axis instead of the array size N.  With this x-axis it is easy to draw the boundaries of the L1, L2 and L3 caches. </p> <p></p> <p>Surprisingly enough, the changes in  the curves coincide with the cache boundaries. As soon as the problem is too large for a cache, cache misses cause  pipeline stalls, and the CPU has to wait for the data needed. The latency increases at every cache boundary and the  slowdown becomes more pronounced each time. This also explains the slight advantage for the AoS case over the SoA  case for problems not fitting in L3. As x, y, and z follow contiguously in memory in the AoS case, when it needs new  data from memory, it has to wait for only a single cache line, while the SoA needs three. If you have difficulties  to grasp, revisit the talk by Scott Meyers CPU Caches and Why You Care.</p> <p>The second question is a bit harder to answer. Let us analyze the performance of the (Fortran) loop:</p> <pre><code>! Contiguous access, SoA: p=[xxx\u2026yyy\u2026zzz\u2026]\ndo ik=1,k\n    do im=1,m                           !  FLOPS\n        r2 = (p(im)-x0)**2              !\n            +(p(m+im)-y0)**2            !\n            +(p(2*m+im)-z0)**2          ! 3-, 2+, 3*\n!       r = lj_pot2(r)                  !\n        r2i = 1.0d0/r2                  ! 1/\n        rr6i = r2i*r2i*r2i;             ! 2*\n        V0j = 4.0d0*rr6*(rr6-1.0d0);    ! 2*, 1-\n    enddo                               !------------\nenddo                                   ! 14 flops\n</code></pre> <p>The loop has 14 floating point operations. It is executed 2^29 times in 1.2s. That makes 6.26\\times 10^9 flops/s. The peak performance of the machine is 1 core x 1 instruction per cycle x 4 SIMD registers per instruction x 2.8 GHz =  11.2 Gcycles/s = 11.2 Gflops/s. Consequently, we are running at 56% of the peak performance. So it looks as if we  could still do better.  </p> <p></p> <p>Let us analyze the data traffic of the same loop:</p> <pre><code>! Contiguous access, SoA: p=[xxx\u2026yyy\u2026zzz\u2026]\ndo ik=1,k\n    do im=1,m                           ! FLOPS         ! DATA\n        r2 = (p(im)-x0)**2              !               !\n            +(p(m+im)-y0)**2            !               !\n            +(p(2*m+im)-z0)**2          ! 3-, 2+, 3*    ! 3DP\n!       r = lj_pot2(r)                  !               !\n        r2i = 1.0d0/r2                  ! 1/            !\n        rr6i = r2i*r2i*r2i;             ! 2*            !\n        V0j = 4.0d0*rr6*(rr6-1.0d0);    ! 2*, 1-        !\n    enddo                               !---------------!-----\nenddo                                   ! 14 flops      ! 24B\n</code></pre> <p>The loop reads 24 bytes x 2^29 iterations in 1.2 s. That makes 10.7 GB/s. The bandwidth of the machine is 109  GB/s for 10 cores, that is 10.9 GB for 1 core. Our loop runs at the maximum bandwidth. It is bandwith saturated.  This is a machine limit. It can simply not feed the CPU with data faster than this. It is instructive to draw a  roofline model for this. </p> <p></p> <p>The above loop, that is the contiguous cases, plot on the bandwidth part of the roofline indicating that the machine  limit (bandwidth) is reached, the random case sits close to the bottom far away from all machine limits. The  conclusion is that the loop as it is runs at its maximum speed, being bandwidth limited. However, 44% of the time  the CPU is not doing useful work, because it is waiting for data. That means that if we replaced the Lennard-Jones  potential with another one that is about twice as compute intensive, and for that reason more accurate, we would still  finish the computation in 1.2s and have a more accurate solution, because we are using the cycles that the CPU was  waiting for data to do the extra computations. </p>"},{"location":"chapter-4/#molecular-dynamics-setting","title":"Molecular Dynamics setting","text":"<p>We consider the same system, a large collection of atoms interacting through a Lennard-Jones potential. In a  Molecular Dynamics setting the time evolution of th system is computed by time integration of the classical equation  of motion:</p> <p>  \\dot{\\mathbf{r}} = \\mathbf{v}  </p> <p>  \\dot{\\mathbf{v}} = \\mathbf{a}  </p> <p>  \\mathbf{a} = \\mathbf{F}  </p> <p>The forces are computed as the gradient of the interaction energy:</p> <p>  \\mathbf{F}_i = \\nabla_{\\mathbf{r}_i}{E} = \\nabla_{\\mathbf{r}_i} \\sum_{j\\ne{i}}^{N}V(r_{ij})  </p> <p>We assume a system size of N=10^9 atoms. The number of terms in the sum above is then 10^9(10^9-1)/2\\approx{10^ {18}}. That will keep us busy, won't it... However, when you start evaluating all these contributions, you very  soon realize that most of them are really small, so small that they don't actually contribute to the result. They  are short-ranged. Mathematically, a force is short-ranged if it decays faster than r^{-2}. This is because the  area of a sphere with radius r is 4\\pi r^2 and hence the number of particles at distance grows as r^2.  Consequently, in order for the force exerted by those particle to be negligible it has to decay faster than r^{-2}.</p> <p>The derivative of the Lennard-Jones potential is:</p> <p>  V'(r) = ({-6}/{r}) r^{-6}(2r^{-6}-1)  </p> <p>Hence,</p> <p>  \\mathbf{F}_i = \\sum_{j\\ne{i}}^{N}\\nabla_{\\mathbf{r}_i}V(r_{ij}) = \\sum_{j\\ne{i}}^{N}V'(r_{ij})\\nabla_{\\mathbf{r} _i}r_{ij} = \\sum_{j\\ne{i}}^{N}V'(r_{ij}) \\hat{\\mathbf{r}}_{ij}  </p> <p>  = \\sum_{j\\ne{i}}^{N} ({-6}/{r_{ij}}) r_{ij}^{-6}(2r_{ij}^{-6}-1) \\frac{\\mathbf{r}_{ij}}{r_{ij}} = \\sum_{j\\ne{i}}^ {N} -6 r_{ij}^{-8}(2r_{ij}^{-6}-1) \\mathbf{r}_{ij}  </p> <p>Note that the force factor f, that is the factor in front of \\mathbf{r}_ij, can also be expressed in terms of  s=r^2=\\delta{x}^2+\\delta{y}^2+\\delta{x}^2:</p> <p>  f(s) = -6 s^{-4}(2s^{-3}-1)  </p> <p>  \\mathbf{F}_i = \\sum_{j\\ne{i}}^{N} f(s_{ij}) \\mathbf{r}_{ij}  </p> <p>So, we can avoid the square root in computing r_ij. Clearly, we can compute the interaction energy and the  interaction force in one go with little extra effort:</p> <p>  V(s) = s^{-3}(s^{-3}-1)  </p> <p>  E = \\sum_{i&lt;j} V(s_{ij})  </p> <p>The fact that the interaction force is short-ranged, allows us to neglect the interaction forces beyond a cutoff  distance r_c, thus offering a possibility to avoid the cost of an O(N^2) algorithm. </p>"},{"location":"chapter-4/#implementing-cutoff","title":"Implementing cutoff","text":"<p>As a first step we we can avoid the computation of the interaction energy and the interaction force if r_{ij}&gt;r_c,  or s_{ij}&gt;s_c:</p> <pre><code># (python psseudo-code)\nfor i in range(N):\n    for j in range(i):\n        x_ij = x[j]-x[i]\n        y_ij = y[j]-y[i]\n        z_ij = z[j]-z[i]\n        s_ij = x_ij*x_ij + y_ij*y_ij + z_ij*z_ij\n        if s_ij &lt;= s_c:\n            t = 1/s_ij\n            t3 = t*t*t\n            E += t3*(t3-1)\n            f = -6*t*t3*(2*t3-1)\n            Fx[i] += f*x_ij\n            Fy[i] += f*y_ij\n            Fz[i] += f*z_ij\n            Fx[j] -= f*x_ij\n            Fy[j] -= f*y_ij\n            Fz[j] -= f*z_ij\n</code></pre> <p>Although this loop only computes the interactions wheen s_{ij}\\le{s_c}, it still visits every pair to compute  s_{ij}. The corresponding amount of work is still O(N^2). Some improvement is possible by using Verlet lists. The Verlet list of an atom i is the set of atoms j for which r_{ij}&lt;r_v, where r_v is typically a bit  larger than r_c. The loop is now witten as:</p> <pre><code># (python psseudo-code)\nfor i in range(N):\n    for j in verlet_list(i):\n        # as above\n</code></pre> <p>The loop over j is now much shorter, its length is bounded, typically in the range 10..100. Hence, the double  loop is effectively O(N). The construction of the Verlet list, however, is still O(N^2), but the cost of it is  amortised over a number of timesteps. Because atoms move only a little bit over a time step and r_v&gt;r_c, the  Verlet list can indeed be reused a number of timesteps, before it needs to be updated. </p> <p>Algorithms for constructing the Verlet list with O(N) complexity do exist. Here's a 2-D version of cell-based  Verlet list construction. It can be easily extended to 3-D, but that is harder to visualise. In the left figure  below, atom i (the orange dot) is surrounded by a blue circle of radius r_v. Atoms inside the blue circle are in  the Verlet list of atom i. We now overlay the domain with a square grid, of grid size r_v (middle figure). Atom  pairs in  the same cell or in nearest neighbour cells are Verlet list candidates, but not pairs in second nearest  neighbours or further. To construct the Verlet list of atom i, we only have to test atoms in the same cell, or in  its 8 nearest neighbours, all coloured light-blue. By iterating over all cells and over the atoms it contains, the  Verlet lists of all atoms can be constructed with O(N) complexity. In fact, by looking for pairs in all  rearest neighbours, all candidate pairs are visited twice (ij and ji). Hence, only half of the nearest  neighbours needs to be visited (right figure). </p> <p></p> <p>The algorithm requires that the grid implements: </p> <ul> <li>a cell list: a list of all the atoms that are in the cell, in order to iterate over all atoms in a cell. The cell    lists can be constructed with O(N) complexity, and </li> <li>a method to find the neighbour cells of a cell. </li> </ul> <p>This is a good example for demonstrating the effectiveness of our  strategy for research software development. Here are the steps  you should take</p> <ol> <li>Start out in Python.</li> <li>Take a small system, e.g. N=5, use Numpy arrays for the positions, velocities, ...</li> <li>Implement brute force computation of interactions and interaction forces (O(N^2)).</li> <li>Implement brute force computation of interactions and interaction forces with cutoff (O(N^2)). </li> <li>Implement brute force construction of Verlet lists (O(N^2)). (You might need a larger system for testing this). </li> <li>Implement Verlet list computation of interactions and interaction forces (O(N)).</li> <li>Implement cell-based Verlet list construction (O(N)). (You might need a larger system for testing this).</li> <li> <p>Optimise, try using Numba, or by taking the compute intensive parts to C++. </p> </li> <li> <p>Of course test and validate every step, e.g. by comparing to previous steps. </p> </li> </ol> <p>Tip</p> <p>Remember that, for performance, you should avoid using loops in Python. When I implemented the  cell-based Verlet list construction in Python, it turned out to be terribly slow, mainly because of 5 levels of  nesting Python loops. The C++ version turned out to be 1200x faster (twelve hundred indeed, no typo!). </p>"},{"location":"chapter-4/#moving-atoms","title":"Moving atoms","text":"<p>The initalization of a physically consistent system of atoms is a non-trivial task in itself. Because molecular motion  conserves energy, random positions and velocities at time t=0 may pos a lot of trouble for time integration. When  two atoms happen to be very close they experience very high repulsive force and thus are accelerated vigorously.  This can easily make the simulation explode. A practical way is to put atoms on a lattice with interatomic distances  close to the equilibrium distance of the Lennard-Jones potential, e.g. primitive cubic, body-centred cubic (BCC),  face-centred cubic (FCC), hexagonal closest packing (HCP). then slowly increase random velocities to increase the  kinetice energy and hence the temperature.</p> <p>When initializing the system on a lattice, often the performance is rather good because the regular arrangement  allows for a good data access pattern. However, as (simulation) time proceeds the atoms move and diffusion kicks in.  Every timestep, some atoms will move in and out of some other atom's Verlet sphere. Gradually, the atoms will move  further and further from their original positions, but their location in memory does not change, and, consequentially,  the data access pattern appproaches the random array access we discussed above, leading to considerable performance  degradation.</p>"},{"location":"chapter-5/","title":"Chapter 5","text":""},{"location":"chapter-5/#a-strategy-for-the-development-research-software","title":"A strategy for the development research software","text":"<p>You are facing a new research question, to be solved computationally and on your shelf of computational tools nothing  useful is found. You start with an empty sheet of paper on you desk. or rather with an empty screen on your laptop.  How you take on such a challenge? This chapter is about a strategy for (research) code development that</p> <ol> <li>minimizes coding efforts, </li> <li>allows for high performance, </li> <li>provides flexible and reusable software components.</li> </ol> <p>Coding efforts is more than just the time to type your program in an editor or IDE. It is also the time you spend  making sure that your code is correct, and stays correct while you are working on it, restructuring its components,  ensuring that it solves the problem you need to solve.</p> <p>High performance is essential when we run our problem on a supercomputer, but perhaps that is not necessary. We want  to postpone performance optimisation until it is really needed. This principle was set in stone in a quote by Donald  Knuth in 1974 already: \"Premature optimisation is the root of all evil\". Spending time on optimisation before it is  needed is wasting time, and stopping progress. Initially, we want to focus on simplicity and correctness, and on  understanding  the characteristics of the problem at hand. If the algorithm we choose to solve is inadequate, we  want to know that as soon as possible. On the other hand, when it is needed, we want our project to be in a state  that facilitates performance optimisation where it is needed.  </p> <p>Finally, we want an approach that builds experience. Flexible and reusable software components are materializing the  experience that we build up. They enable us to proceed faster when pieces of a last year's problem may be useful  today. Two important aspects of reusable code are writing simple functions and classes with a single functionality,  and documentation. Well documenting your code increases the chance that when you check out your code three months  later, you will not be staring baffled at your screen wondering what it was all about. It happens to me, it can  certainly happen to you. </p> <p>None of these features come without effort. It is also not a bucket list of checkboxes to make sure that you did  not overlook something. They comprise a learning process, require attention, disipline and research. </p> <p>Here is a story that demonstrates an anti-pattern for research code development. </p> <p>Note</p> <p>The term pattern refers to a set problems with common features that can be efficiently solved with the same  approach, by applying the pattern. The term comes from a very useful  book \"Design Patterns - Elements of reusable  object-oriented software\", by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, 1995. Several  \"pattern\" books later transferred the approach to other domains. </p> <p>An anti-pattern is a pattern that perhaps solves the problem, or not, but if it does, in pessimal way. It is a  pattern NOT to follow.</p> <p>A PhD student once asked me for support. He had written a 10 000 line Fortran program. When he ran it, the results  were not what he expected, and he suspected that there was a bug 'somewhere'. He asked if I could help him find the  bug and - no kidding - by the end of next week, because the program had to go into production by then. I had to  disappoint him and told him that he needed a 'true' magician, which I, unfortunately, was not. Obviously, the program  was flawed in some sense, but other than a bug it might just as well be one or more of the situations below:</p> <ul> <li>The program may contain many bugs, which is very well possible in view of its size. On average a programmer    introduces about 1 bug in every 10 lines of code! Check this link for some amazing facts </li> <li>The algorithm for solving the problem is inappropriate. </li> <li>There is an accuracy problem, related e.g. discretisation of time, space, or a insufficient basis function for    expanding the solution, or related to the finite precision of floating point numbers. (Floating point numbers are a    processor's approximation of the real numbers, but they do have different mathematical properties. E.g. floating    point addition is not commutative.)</li> <li>The mathematical formulation itself could be flawed or misunderstood.</li> <li>The program is correct, but the researchers expectations are wrong. </li> <li>...</li> </ul> <p>It could easily take weeks, if not months to write tests for the individual components to learn about the behaviour  of the program and narrow down to the source of the error. This anti-pattern is a disaster waiting to happy.</p> <p>For this reason a sound strategy that makes sure that the code you write is correct, that does what you want, and  builds understanding of the problem at hand as you proceed, is indispensable. The strategy proposed below has been  shaped by a lifetime of research software developement. I use it in nearly every software project I take on, whether  it is small or big, simple or complex, starting from scratch or from someone else code. </p> <p>The proposed strategy builds on five principles:</p> <ol> <li>Start out in a high level programming language. Python is an excellent choice.</li> <li>Start out simple, as simple as possible, in order to build up understanding of your problem and how it should     be solved fast. </li> <li>Test and validate your code, continuously, and for small code fragments, to discover bug and mistakes as soon as     possible. </li> <li>Improve your code, adding better algorithms (which usually are more complex), pay attention to data structure     facilitating good data access patterns, think of common sense optimisations,     gradually increase the complexity of the problem.    Keep principle 3. in mind and continue testing and validating the improvements.</li> <li>If neccessary, optimise your code. Necessary is when the time to solution is too long.</li> <li>If necessary, parallelise your code. Necessary is when the time to solution is still too long after paying     attention to principle 5., or if the problem does not fit in the memory of a single machine. In that case it it     advisable to optimise anyway to not waste cycles on an expensive supercomputer. </li> </ol> <p>Tip for researchers of the University of Antwerp and institutes affiliated with the VSC</p> <p>Researcher of the University of Antwerp and institutes affiliated with the VSC are  wellcome to contact me for support when developing research software. The best time to do that would be before  having written any line of code at all for the problem, in order to follow all principles.    </p> <p>The ordering of the list is important and reflects the successive steps in working on a project. Below, we explain these principles in depth.</p> <p>Much of the wisdom of this strategy is integrated into a Python application micc2.</p>"},{"location":"chapter-5/#principle-1","title":"Principle 1","text":""},{"location":"chapter-5/#start-out-in-a-high-level-language","title":"Start out in a high level language","text":"<p>Python is an excellent choice:</p> <ul> <li>Python is a    high-level general-purpose programming language    that can be applied to many different classes of problems. </li> <li>Python is easy to learn. It is an interpreted and interactive language and programming in Python is intuitive,    producing very readable code, and typically significantly more productive than in low-level languages as    C/C++/Fortran. Scripting provides a very flexible approach to formulating a research problem, as compared to an    input file of a low-level language program. </li> <li>It comes with a large standard Library</li> <li>There is wide variety of third-party extensions, the Python Package Index(PyPI). Many packages    are built with HPC in mind, on top of high quality HPC libraries. </li> <li>The functionality of standard library and extension packages is enabled easily as <code>import module_name</code>, and    installing packages is as easy as: <code>pip install numpy</code>. The use of modules is so practical and natural to Python    that researchers do not so often feel the need to reinvent wheels.</li> <li>Availability of High quality Python distributions (   Intel, Anaconda), cross-platform Windows/Linux/MACOS</li> <li>Python is open source. In itself that is not necessarily an advantage, but its large community guarantees an    very good documentation, and for many problems high-quality solutions are found readily on user forums.  </li> <li>Python is used in probably any scientific domain, and may have many third party extension freely available in that    domain. It is available with a lot scientific Python packages on all VSC-clusters.</li> <li>Several high-quality Integrated Development Environments (IDEs) are freely available for Python: e.g. PyCharm, VS Code, which at the same time    provide support for C/C++/Fortran.</li> <li>Although Python in itself is a rather slow language, as we will see, there are many ways to cope with performance    bottlenecks in Python. </li> </ul> <p>The quality of Python is embodied it its design principles \"The Zen of Python\" which are printed when you <code>import  this</code>. Many of these also apply to our strategy for developing research software.</p> <pre><code>&gt; python\n&gt;&gt;&gt; import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n</code></pre> <p>In many ways, Python gently pushes you in the right direction, providing a pleasant programming experience.</p> <p></p> <p>As an alternative on could consider Julia. Following a different programming paradigm, called  multiple dispatch, its learning curve is probably a bit steeper  and it has a smaller community. However, it is more performant than Python. On the other hand its programming  productivity might not be that of Python. </p> <p>An other alternative could be Matlab. Although it has a long  history of scientific computing, from as a language is it not as well designed as Python, and it is not fit for HPC.  Moreover, it is a commercial product, and the community using it is not as willing to share its solutions as for  Python, and there are much less extensions available. Often, you will need to solve the problem yourself, and, as a  consequence, proceed at a slower pace.</p> <p>Starting out in a low-level programming language (C/C++/Fortran) is certainly a bad idea. Even if you are an  experienced programmer you will proceed slower. The productivity of Python is easily 10 times larger than for  C/C++/Fortran because:</p> <ul> <li>the advantages coming with an interpreted language, vs. a compiled language,</li> <li>the fact that Python is a very well designed, expressive and readable language with a rather flat learning curve,</li> <li>the availability of a large standard library and a wide range of domain-specific third party extensions, as well    as the ease with which these are enabled in your code.</li> </ul> <p>Hence, this course sticks to Python. </p>"},{"location":"chapter-5/#principle-2","title":"Principle 2","text":""},{"location":"chapter-5/#start-out-as-simple-as-possible","title":"Start out as simple as possible","text":"<p>Take a small toy problem, the smallest you can think of that still represents the problem that you want to  solve. There is a famous quote, attributed to Einstein  (although it seems he formulated it differently) \"Make everything as simple as possible, but not simpler\". That applies very well here. The simpler the problem  you start with, the faster you will build experience and understanding of the problem. Ideally, take a problem  with a known analytical solution. Look for something you can easily visualise. Four atoms are easier to visualise  than a hundred. Visualisation is a perfect way for obtaining insight (pun intended!) in your problem. Choose the  simplest algorithm that will do the trick, don't bother about performance. Once it works correctly, use it as a  reference case for validating improvements.  </p> <p>Here are some interesting Python modules for visualisation:</p> <ul> <li>matplotlib</li> <li>bokeh</li> <li>plotly</li> <li>seaborn</li> </ul>"},{"location":"chapter-5/#principle-3","title":"Principle 3","text":""},{"location":"chapter-5/#test-and-validate-your-code-changes","title":"Test and validate your code (changes)","text":"<p>In view of these amazing facts on the abundance of bugs in code  there seems to be little chance that a programmer writes 100 lines of code without bugs. On average 7 bugs are to be  expected in every 100 lines of code. Probably not all these bugs affect the outcome of the program, but in research  code the outcome  is of course crucial. How can we ensure that our code is correct, and remains so as we continue to  work on it? The answer is unit-tests. Unit-testing are pieces of  test-code together with verified outcomes. In view of the abundancy of bus it is best to test small pieces of code,  in the order of 10 lines. Test code is also code and thus can contain bugs as well. The amount of test code for a  system can be large. An example is probaly the best way to demonstrate the concept. In chapter 4 we discussed the  case study  Monte Carlo ground state energy calculation of a small atom cluster and a small project wetppr/mcgse where the original study is repeated with a Morse potential,  described by the formula:</p> <p> </p> <p>The code for this function is found in wetppr/mcgse/init.py. Note that we  provided default unit values for all the parameters: </p> <pre><code>import numpy as np\n\ndef morse_potential(r: float, D_e: float = 1, alpha: float = 1, r_e: float = 1) -&gt; float:\n    \"\"\"Compute the Morse potential for interatomic distance r.\n\n    This is better than it looks, we can pass a numpy array for r, and it will\n    use numpy array arithmetic to evaluate the expression for the array.\n\n    Args:\n        r: interatomic distance\n        D_e: depth of the potential well, default = 1\n        alpha: width of the potential well, default = 1\n        r_e: location of the potential well, default = 1\n    \"\"\"\n    return D_e * (1 - np.exp(-alpha*(r - r_e)))**2\n</code></pre> <p>The implementation of the function comprises only one line. How can we test its correctness? One approach would be  to list a few r-values for which we know the outcome. E.g. V(r_e) = 0. Here is a test funtion for it. Note that </p> <pre><code>from math import isclose\n\ndef test_morse_potential_at_r_e():\n    # the value at r_e=1 is 0\n    r = 1\n    Vr = mcgse.morse_potential(x)\n    Vr_expected = 0\n    assert isclose(Vr, Vr_expected, rel_tol=1e-15)\n</code></pre> <p>Because the function is using floating point arithmetic, the outcome could be subject to roundoff error. We account  for a relative error of <code>1e-15</code>. When running the test, an AssertionError will be raised whenever the relative  error is larger than <code>1e-15</code>.  When it comes to testing functions it is practical to focus on mathematical properties of the function (fixing  parameters to unity). E.g.</p> <ul> <li> 0 \\le V(r)  for r \\in ]0,1],</li> <li> 0 \\le V(r) &lt; 1  for r \\in [1,+\\infty[,</li> <li> V(r) is monotonously decreasing on ]0,1], </li> <li> V(r) is monotonously increasing on [1,+\\infty[, </li> <li> V''(r) is positive on ]0,1],</li> <li> V''(r) is positive on ]1,r_i], r_i=1 - \\log(1/2) being the inflection point,</li> <li> V''(r) is negative on ]r_i, +\\infty[,</li> <li>...</li> </ul> <p>See <code>tests/wetppr/mcgse/test_mcgse.py</code> for details. The file contains many more tests for other functions in the file  <code>wetppr/mcgse/__init__.py</code>. </p>"},{"location":"chapter-5/#automating-tests","title":"Automating tests","text":"<p>As soon as you have a few tests, running them manually after every code change, becomes impractical. We need to automate running the tests. Several automated test runners are available. Pytest  is a good choice. When given a directory as a parameter, it will import all <code>test_*.py</code> files under it, look for  methods starting with <code>test</code>, execute them and produce a concise report about which tests pass and which tests fail. Details about test discovery are found here.</p> <pre><code>&gt; cd path/to/wetppr\n&gt; pytest tests\n==================================== test session starts =====================================\nplatform darwin -- Python 3.9.5, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nrootdir: /Users/etijskens/software/dev/workspace/wetppr\nplugins: typeguard-2.13.3, mpi-0.5, anyio-3.6.2\ncollected 6 items\n\ntests/wetppr/mcgse/test_mcgse.py .....                                                 [100%]\n\n===================================== 5 passed in 1.65s ======================================\n</code></pre> <p>As is clear from the output above it  found 5 tests in <code>tests/wetppr/mcgse/test_mcgse.py</code>, all executed successfully. In the presence of errors it is  instructive to run <code>pytest</code> with <code>-v -s</code> options.</p> <p>For every new method added to your code, add some tests and run <code>pytest</code>. For every code change run all the tests  again. Make sure they pass before you continue to improve or extend the code.</p>"},{"location":"chapter-5/#debugging-a-failing-test","title":"Debugging a failing test","text":"<p>Debugging is the process of stepping through a program, executing it line by line, and examining the results in  order to find the source of the error. IDEs like PyCharm and  VS Code provide a most friendly debugging experience, but you can also use the  Python debugging module pdb:</p> <p>Debugging a failing test is often the best way to investigate the source of the error. </p> <p>Python has an interesting idiom that allows a module to be run as a script, i.e. execute a module. To that end you put this code snippet at the  end of a module:</p> <pre><code>#\n# module code here\n#\nif __name__ == \"__main__\":\n    #\n    # script code here.\n    #\n    print(\"-*# finished #*-\") # if this line doesn't show up, something went wrong. \n</code></pre> <p>The idiom has no common name :-(, we will refer to it as the <code>if __name__ == \"__main__\":</code> idiom. </p> <p>If a module file is imported as in <code>import module_name</code>, only the module code is executed, and the body of the <code>if</code>  statement <code>if __name__ == \"__main__\":</code> is ignored, because the <code>import</code> statement sets the value of the <code>__name__</code>  variable to the module name. Thus, the condition evaluates to <code>False</code>. Most of the module code will consist of <code>def</code>  and <code>class</code> statements, defining methods (the Python term for a function) and classes. When Python executes a <code>def</code>  or a <code>class</code> statement, it interprets the code of the method or class and registers them under their respective  names, so that they can be called by the module or script that imported the module.</p> <p>If the module file is executed on the command line, as in the command <code>python module_name.py</code> or in an IDE, the  <code>python</code> executable sets the <code>__name__</code> variable to <code>\"__main__\"</code>. Thus, the condition evaluates to <code>True</code> and its  body is executed. </p> <p>This Python idiom provides us with a practical approach for executing a failing test. Assume that by running <code>pytest  tests</code> we find out that there is an error in the test function <code>test_morse_potential_mathematical_properties</code>:</p> <pre><code>&gt; pytest tests\n==================================== test session starts =====================================\nplatform darwin -- Python 3.9.5, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nrootdir: /Users/etijskens/software/dev/workspace/wetppr\nplugins: typeguard-2.13.3, mpi-0.5, anyio-3.6.2\ncollected 6 items\n\ntests/wetppr/test_wetppr.py .                                                          [ 16%]\ntests/wetppr/mcgse/test_mcgse.py .F...                                                 [100%]\n\n========================================== FAILURES ==========================================\n________________________ test_morse_potential_mathematical_properties ________________________\n...\n================================== short test summary info ===================================\nFAILED tests/wetppr/mcgse/test_mcgse.py::test_morse_potential_mathematical_properties - ass...\n================================ 1 failed, 5 passed in 4.27s =================================\n\n</code></pre> <p>At the end of the test module <code>tests/wetppr/mcgse/test_mcgse.py</code>, which contains the failing test  <code>test_morse_potential_mathematical_properties</code> you will see this code snippet:</p> <pre><code>#\n# test functions here\n#\nif __name__ == \"__main__\":\n    the_test_you_want_to_debug = test_energy\n\n    print(\"__main__ running\", the_test_you_want_to_debug)\n    the_test_you_want_to_debug()\n    print(\"-*# finished #*-\")\n</code></pre> <p>When we run <code>pytest tests</code>, pytest imports the test module, setting <code>__name__</code> to <code>\"test_mcgse\"</code>. Hence the  condition <code>__name__ == \"__main__\"</code> evaluates to <code>False</code> and its body is not executed. Only when the module is  executed the body will be executed too. Since we want to run the <code>test_morse_potential_mathematical_properties</code>  function, change the first line in the body to:</p> <pre><code>    the_test_you_want_to_debug = test_morse_potential_mathematical_properties\n</code></pre> <p>The variable <code>the_test_you_want_to_debug</code> now is an alias for the test function that we want to debug,  <code>test_morse_potential_mathematical_properties</code>. The next statement is a print statement producing something like:</p> <pre><code>__main__ running &lt;function test_morse_potential_mathematical_properties at 0x11098c310&gt;\n</code></pre> <p>which ensures us that we called the right test function. The test function is then called in the next statement  through its alias <code>the_test_you_want_to_debug</code>:</p> <pre><code>    the_test_you_want_to_debug()\n</code></pre> <p>To debug the test using pdb execute:</p> <pre><code>&gt; python -m pdb tests/wetppr/mcgse/test_mcgse.py\n</code></pre>"},{"location":"chapter-5/#quick-and-dirty-testing","title":"Quick and dirty testing","text":"<p>The <code>if __name__ == \"__main__\":</code> idiom has another interesting application. When working on small projects, with only a  few functions, sometimes we don't want to set up a <code>tests</code> directory with a <code>test_small_module.py</code> file. Instead we  can use the <code>if __name__ == \"__main__\":</code> idiom to write a quick and dirty test inside the module, or just call the  function to check by running or debugging the module that it does the right thing. In this way your work is  restricted to a single file, and there is no need to switch between the test file and the module file.</p>"},{"location":"chapter-5/#principle-4","title":"Principle 4","text":""},{"location":"chapter-5/#improve-and-extend-the-code","title":"Improve and extend the code","text":"<p>Once the code for the simple problem you started with (see Principle 2) is  tested, validated, and understood, you can gradually add complexity, approaching the true problem you need to solve.  This may require improvements to the code because the time to solution will probably increase. Possible improvements  are: </p> <ul> <li>better algorithms with lower computational complexity,</li> <li>better data structures, facilitating good data access patterns,</li> <li>common sense optimisations, </li> <li>increasing the flexibility of the code,</li> <li>restructuring the code,</li> <li>gradually increase the complexity of the problem.</li> </ul> <p>Obviously, continue to test and validate all code changes and extensions.</p>"},{"location":"chapter-5/#principle-5","title":"Principle 5","text":""},{"location":"chapter-5/#optimise-if-necessary","title":"Optimise if necessary","text":"<p>If neccessary, optimise your code. Necessary is when the time to solution is too long. At this point you will  probably already have a considerable Python code base. Bearing in mind that  premature optimisation is the root of all evil, the important question is what needs optimisation and what not.  The answer is provided by using a profiler. Profiler are tools that tell you how much time your program spends in  the different parts of it and how many times tha part is executed.</p> <p>Some profilers provide information on a per function basis, and tell how many times that function was called and  the average or cumulative time spent in it. Other profilers provide information on a per line basis, an tell how  many times that line was executed and the average or cumulative time spent on it. This article provides the necessary details.</p> <p>You should start profiling on a per function basis and then profile the function(s) consuming most time with a  line-by-line profiler. If it turns out that only a few lines of the function are responsible for the runtime  consumption, split them off in a new function and try optimising the new function using one of the techniques discussed  below. If not, try optimising the whole function with the very same techniques.</p> <p>Tip</p> <p>After optimising a (split-off) function, run the profiler again to check the performance.  </p>"},{"location":"chapter-5/#techniques-for-optimising-performance","title":"Techniques for optimising performance","text":"<p>Below a series of optimisation techniques is presented, ordered by development effort needed.</p>"},{"location":"chapter-5/#use-python-modules-built-for-hpc","title":"Use Python modules built for HPC","text":"<p>There exist excellent Python modules that provide very performant high level data structures and operations. Using  them can make a dramatic difference. E.g. the difference in performance between Python lists and Numpy arrays can easily be a factor 100. By using them you do not only gain performance. Once you have learned how to  use a Python module, such as Numpy, development time is also reduced as you no longer have to code the low-level  logic yourself. Here are a few interesting scientific Python modules:</p> <ul> <li>Numpy: n-dimensional arrays, mathematical functions, linear algebra, ...</li> <li>SciPy: fundamental algorithms for scientific computing...</li> <li>sympy: symbolic computation</li> <li>pandas: data analysis</li> </ul>"},{"location":"chapter-5/#numba","title":"Numba","text":"<p>Numba is a compiler for Python array and numerical functions that gives  you the power to speed up your applications with high performance functions written directly in Python. It takes  your Python code, transforms it into C code, compiles it (on the fly) and calls the compiled C code version. Here is  how a Numba-optimized function, taking a Numpy array as argument, might look like: </p> <pre><code>import numba \n\n@numba.jit \ndef sum2d(arr):\n    M, N = arr.shape\n    result = 0.0\n    for i in range(M):\n        for j in range(N):\n            result += arr[i,j]\n    return result\n</code></pre> <p>the <code>@numba.jit</code> decorator instructs the Python interpreter to use the numba just-in-time compiler (jit) to  translate the Python code int C. compile it, and use the compiled verson on every call. As pure Python loops are  quite expensive and the function has a double Python loop over 'i' and 'j' the performance gain is considerable. As in principle it only involves adding a decorator (and possibly some hinting at data types) using numba can be a  really quick win. </p> <p>Note</p> <p>The above function can also defined as <code>np.sum(np.sum(arr))</code>, using numpy function calls exclusively. That might  be even faster.</p> <p>Tip</p> <p>Numba is sensitive to data types. Changing the data type of the arguments can improve the situation a lot.  </p>"},{"location":"chapter-5/#developing-your-own-modules-in-cfortran","title":"Developing your own modules in C++/Fortran","text":"<p>If none of the above techniques helps, you might consider to develop your own Python modules compiled from C++ or  Fortran code, also known as binary Python extensions. This can be a real game changer. In fact, this is exactly what  the HPC Python modules like Numpy and SciPy do, and they do it because that is the way to harness the power of  modern CPUs and expose it to Python. Obviously, this requires good knowledge of C++ or Fortran, and good  understanding of performance critical characteristics fo modern CPU architecture. </p> <p>The application micc2  facilitates building your C++ and Fortran modules. Checkout its  tutorials.</p>"},{"location":"chapter-5/#principle-6","title":"Principle 6","text":""},{"location":"chapter-5/#parallelise-if-necessary","title":"Parallelise if necessary","text":"<p>If necessary, parallelise your code. Parallelisation is necessary is when the time to solution is still too long after  paying attention to principle 4 and principle 5, or if the  research problem does not fit in the memory of a single machine. In that case it is advisable to optimise  (principle 5) anyway to not waste cycles on an expensive supercomputer. </p> <p>To parallelise Python projects these tools come in handy: </p> <ul> <li>dask: multi-core and multi-node parallellisation</li> <li>mpi4py: MPI parallellisation with python</li> </ul>"},{"location":"evaluation/","title":"Evaluation of this course","text":"<p>In this course you will be learning by doing. You will be given an assignment, a (parallel)  programming task on which you will work for several weeks, under my supervision and with my support. </p> <p>The exam consists of a presentation of your project work (usually in the last week of the course) in which you must</p> <ul> <li>explain the problems you encountered,</li> <li>explain your approach,</li> <li>provide performance measurements for the different versions your code, and for different node counts,</li> <li>explain the performance measurements,</li> <li>tell me what you found difficult during this course.</li> </ul> <p>During the presentation I will ask some questions, mainly because I am curious and eager to learn something, but also  to ensure that you understand what you present.</p>"},{"location":"evaluation/#assignment","title":"Assignment","text":"<p>Here is this year's assignment.</p>"},{"location":"evaluation/#guide-lines","title":"Guide lines","text":""},{"location":"evaluation/#create-a-github-repo-for-your-project-work","title":"Create a Github repo for your project work","text":"<p>The code that you write must be regularly committed to a GitHub repository. This has many advantages:</p> <ul> <li>First, it serves as a backup. Every single commit can be retrieved at all times. So, you can't loose your code,    even not the older versions.</li> <li>Everyone with access to the repository can access the code. If you keep the repository public, that means everyone    with access to the internet. If you make it private, only the people you invite can access. </li> <li>It is important that you give me access. If you have problems, I can clone your repository and debug it to see    what is going wrong,</li> <li>If you cooperate with another student on the project you can exchange updates easily. You can make use of git    branches to avoid bother other people with your code changes before they are correct.  </li> </ul> <p>The presentation must have been added to your GitHub repository before you give your presentation. I will keep a  copy of your project repo as a proof of your work.</p>"},{"location":"evaluation/#learning-by-doing","title":"Learning by doing","text":"<p>The assignment is there because imho programming is something you can only learn by doing. It involves  important skills that you should develop while working on the assignment:</p> <ul> <li>Using the background information presented in chapters 1-4</li> <li>Reason abuot the mathematical formulation of the problem and the algorithm to solve it,</li> <li>Do research on the problem, with respect to solution algorithms and implementation issues.</li> <li>Write and debug code in Python. </li> <li>Learn how slow Python functions can be sped up by converting them to either C++ or Fortran. </li> <li>Run your code on one of the UAntwerp HPC clusters.</li> </ul> <p>Learning is an incremental process. Especially for scientific software development the following is a good approach:</p> <ol> <li>Try, and test (We'll see what testing exactly means). </li> <li>Fail (often, the faster you fail, the faster you learn! ).   </li> <li>Think and do research (Google - or any other good search engine, for that matter - is your best friend), and     come up with an improvement. This is the hardest part, it requires intelligence and creativity.</li> <li>Iterate, i.e. restart at 1., until you no more fail and are satisfied with the solution.</li> <li>Document your itinerary. Document your classes, functions, variables, and keep track of the documents     that guided you to solving the problems encountered. When you will look at your work three months (only!) after     you left it as is, you will wonder what it was all about if you didn't document it. </li> </ol> <p>Although this approach may look as if you are supposed to find the solution to the problem in books or on the World  Wide Web, this does not at all exclude creativity. Learning about how other researchers approached a problem, can  easily spark new ideas that get you going. The fail fast, fail often principle also </p> <ul> <li>urges you to start as simple as possible and </li> <li>make incremental changes. </li> </ul> <p>Don't write a lot of code before you try and test. Typically, and this is corroborated by research, one bug is introduced with every new 10 lines. Finding 10 bugs in 100 lines is  a lot more difficult than finding one bug in 10 lines (although sometimes there is more than one bug :( ). </p> <p>A PhD student once asked me for support. He had written a 10 000 line Fortran program (without tests). When he ran it, the results were not what he expected and he suspected that there was a bug  'somewhere'. He asked if I could help him find the bug and - no kidding - by the end of next week because the  program had to go into production by then. I had to disappoint him and told him that he needed a true magician,  which I am not. Obviously, the program was flawed in some sense, but other than a bug it might just as well be:</p> <ul> <li>The program contains many bugs, which is very well possible in view of its size.</li> <li>The algorithm for solving the problem is inappropriate.</li> <li>There is an accuracy problem, related e.g. discretisation of time, space, or a insufficient basis function for    expanding the solution, or related to the finite precision of floating point numbers. (Floating point numbers are a    processor's approximation of the real numbers, but they do have different mathematical properties. E.g. floating    point addition is not commutative.)</li> <li>The mathematical formulation itself could be flawed or misunderstood.</li> <li>It is even possible that the program is correct but that the researchers expectations are wrong. </li> <li>...</li> </ul> <p>It could easily take weeks, if not months to write tests for the individual components to learn about the behaviour  of the program and narrow down to the source of the error. </p> <p>For this reason a sound strategy for scientific software development that makes sure that the code you write has a  sense of correctness is indispensable. Had the researcher come to me before he started programming this is the  advice he would have been given: </p> <p>Advice</p> <p>Write 5 lines of code and test them before you proceed (with the next 5 lines). Just 5, not 10! Your test  code is also code and will initially contain bugs as well. As you get more experienced you may increase that  number  to 6, even 7, ...  </p> <p>Admittedly, this advice is slightly biased to the conservative side, but I hope you get the point. You will be  surprised how many mistakes you make, being a novice. But as you will discover the source of error soon, your  progress will not come to halt. Instead you will learn fast and your progress will even speed up. I will give you  practical tools to accomplish this. </p>"},{"location":"glossary/","title":"Glossary","text":"<p>Here is an alphabetical list of terms with links to where they are explained in the text.</p>"},{"location":"glossary/#a","title":"A","text":"<ul> <li>address space</li> <li>anti-pattern</li> <li>array of structures</li> </ul>"},{"location":"glossary/#b","title":"B","text":"<ul> <li>bandwidth limited</li> <li>bandwith saturated</li> </ul>"},{"location":"glossary/#c","title":"C","text":"<ul> <li>Cache coherence</li> <li>cache coherent non-uniform memory architecture</li> <li>cache line</li> <li>cache-oblivious</li> <li>ccNUMA</li> <li>cell-based Verlet list construction</li> <li>code modernisation</li> <li>Code optimisations</li> <li>Common sense optimizations</li> <li>communication</li> <li>computational complexity</li> <li>computational intensity</li> <li>compute limited</li> <li>compute node</li> </ul>"},{"location":"glossary/#d","title":"D","text":"<ul> <li>Debugging</li> <li>Distributed memory parallelization</li> </ul>"},{"location":"glossary/#e","title":"E","text":"<ul> <li>embarrassingly parallel</li> </ul>"},{"location":"glossary/#h","title":"H","text":"<ul> <li>hardware thread</li> <li>Hybrid memory parallelization</li> </ul>"},{"location":"glossary/#i","title":"I","text":"<ul> <li>instruction pipelining</li> </ul>"},{"location":"glossary/#l","title":"L","text":"<ul> <li>L1 cache</li> <li>L2 cache</li> <li>L3 cache</li> <li>loop fusion</li> </ul>"},{"location":"glossary/#m","title":"M","text":"<ul> <li>main memory</li> <li>memory bandwidth</li> <li>multi-core</li> <li>multi-processor</li> </ul>"},{"location":"glossary/#n","title":"N","text":"<ul> <li>node</li> <li>NUMA</li> </ul>"},{"location":"glossary/#p","title":"P","text":"<ul> <li>parallel program</li> <li>Partitioned Global Address Space</li> <li>pattern</li> <li>peak performance</li> <li>pipeline stalls</li> <li>process</li> <li>profiling</li> </ul>"},{"location":"glossary/#r","title":"R","text":"<ul> <li>registers</li> </ul>"},{"location":"glossary/#s","title":"S","text":"<ul> <li>sequential</li> <li>serial</li> <li>shared memory parallelization</li> <li>short-ranged</li> <li>SIMD vectorisation</li> <li>software thread</li> <li>Spatial locality</li> <li>structure of Arrays</li> </ul>"},{"location":"glossary/#t","title":"T","text":"<ul> <li>Temporal locality</li> <li>thread</li> <li>tiling</li> <li>time to solution</li> </ul>"},{"location":"glossary/#v","title":"V","text":"<ul> <li>Verlet list</li> </ul>"},{"location":"links/","title":"Useful links","text":""},{"location":"links/#c","title":"C++","text":"<ul> <li>cplusplus.com</li> <li>cppreferencee.com</li> </ul>"},{"location":"links/#fortran","title":"Fortran","text":"<ul> <li>fortran-lang.org</li> </ul>"},{"location":"links/#python","title":"Python","text":"<ul> <li>python.org</li> <li>realpython.com</li> </ul>"},{"location":"links/#parallelization-approaches","title":"Parallelization approaches","text":"<ul> <li>OpenMP: C/C++/Fortran</li> <li>MPI: C/C++/Fortran</li> <li>mpi4py: Python, the documentation of mpi4py is not self-contained. It    relies (silently) on the documentation of MPI.</li> <li>multiprocessing: Python</li> <li>concurrent.futures: Python</li> <li>dask: Python</li> </ul>"},{"location":"links/#hpc","title":"HPC","text":"<ul> <li>Georg Hager's blog</li> <li>SC20 tutorial \u201cNode-Level Performance Engineering\u201d: This is all about    \"When to parallelize, and what to do first\".</li> </ul>"},{"location":"links/#project-management","title":"Project management","text":"<ul> <li> <p>micc2: managing your Python/C++/Fortran project, helps with</p> </li> <li> <p>creating new projects</p> </li> <li>adding Python sub-modules, Python applications (CLIs), binary extension modules written in C++ and Fortran. </li> <li>automatically extracting documentation from the doc-strings of your files (html or pdf)</li> <li>(unit) testing (pytest)</li> <li>publishing the documentation on readthedocs</li> <li>publishing your code on the Python package index </li> <li>version management and control (on GitHub)</li> </ul>"},{"location":"links/#other-courses","title":"Other courses","text":"<ul> <li>This</li> <li>The Missing Semester of Your CS Education</li> </ul>"},{"location":"over-de-auteur/","title":"Over de auteur","text":""},{"location":"over-de-auteur/#engelbert-tijskens","title":"[Engel]bert Tijskens","text":"<ul> <li>Lic. Aard- en delfstofkunde, Master in Physics of Microelectronics and Material Sciences, Doctor in de    Natuurwetenschappen - ik heb dus eigenlijk geen opleiding genoten in programmeren of wetenschappelijk rekenen ...    maar veel opleidingen bijgewoond, en vooral veel gelezen tijdens mijn voortdurende zoektocht naar betere manieren    om de opdrachten waar ik voor stond uit te voeren.  </li> <li>ik werk sinds 2012 voor CalcUA, de UA    kernfaciliteit voor supercomputing, en voor het VSC, het Vlaams Supercomputer Centrum.   Ik verzorg er opleiding en ondersteuning van onderzoekers rond wetenschappelijk programmeren voor HPC-omgevingen    en performantie-analyse. k ben gepassioneerd door Python, C++, Fortran en libraries en frameworks    waarmee hoog-performante en parallelle applicaties kunnen gebouwd worden.</li> <li>Sinds 2014 geef ik het vak \"Parallel programmeren\". Ik geef graag les en wil mijn ervaring van 30 jaar    wetenschappelijk programmeren delen met jonge onderzoekers.</li> <li>Voor 2012 leidde ik de DEM Research Group aan de KU Leuven. DEM staat voor Discrete Element Modelling.    Je kan het vergelijken met Molecular Dynamics, maar dan in de macroscopische wereld met atomen die een vorm    hebben, korrels dus, of grains in het Engels. Daarom wordt het ook Granular Dynamics genoemd.    Korrelstromen komen in heel wat industri\u00eble processen voor en het modelleren ervan is interessant, om inzicht te    verwerven in korrelige processen en om er goede procesinstallaties voor te ontwerpen. Dit is erg uitdagend omdat de    fysica van korrelige processen zo complex is. In tegenstelling tot MD zijn interacties tussen korrels dissipatief    en worden de contactkrachten bepaald door materiaaleigenschappen en oppervlakte-eigenschappen en zijn er zowel    normale als tangenti\u00eble contactkrachten (wrijving). Bovendien zijn de korrels - afhankelijk van het materiaal -    soms vervormbaar, of zelfs breekbaar. Omdat korrelige processen vaak over heel veel deeltjes gaan, zijn    performantie en parallellisatie essentieel. De simulatiesoftware waar we toen aan werkten, wordt nu    gecommercialiseerd door Mpacts. </li> </ul>"},{"location":"over-de-auteur/#enkele-voorbeelden","title":"Enkele voorbeelden","text":"<p>Kijk op Mpacts case studies voor meer voorbeelden. </p>"},{"location":"over-de-auteur/#cnh-maaidorser-ontwikkeld-met-mpacts","title":"CNH maaidorser - ontwikkeld met Mpacts","text":"<p>Hier zijn verscheidene korrelige processen aan de orde:</p> <ul> <li>de strohalmen maaien en binnen trekken in de machine,</li> <li>de graantjes losmaken van de aar en ze scheiden van het stro,</li> <li>stro afvoeren naar achter,</li> <li>het kaf van het koren scheiden (kaf weg blazen),</li> <li>het graan transporteren naar de verzamelbak bovenaan de machine,</li> <li>het graan transporteren van de verzamelbak naar de aanhangwagen achter de tractor,</li> </ul>"},{"location":"over-de-auteur/#spherische-korrels-die-op-een-trampoline-vallen","title":"Spherische korrels die op een trampoline vallen","text":""},{"location":"over-de-auteur/#mpacts-ijsbreker","title":"Mpacts: ijsbreker","text":"<p>Mpacts simulatie van een ijsbreker die door een ijslaag breekt.</p> <p></p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#goals","title":"Goals","text":"<ul> <li>What is parallel programming?</li> <li>Why parallel programming?</li> <li>Performance is important</li> <li>How to parallelize a program?</li> <li>Tools</li> <li>Principles and best practices</li> <li>Strategy for scientific software development</li> </ul>"},{"location":"overview/#background-knowledge","title":"Background knowledge","text":"<ul> <li>The working of a modern processor</li> <li>CPU architectory and hierarchical memory architecture<ul> <li>A short introduction: Memory location matters for performance</li> <li>A very good talk about this topic, you need to see this: Scott Meyers on Cpu Caches    and Why You Care </li> </ul> </li> <li>Accelerators (GPU), increasingly important topic, but we cannot treate everything in this course. </li> <li>The architecture of a supercomputer</li> <li>Nodes</li> <li>Interconnect</li> <li>Accelerators (GPU), increasingly important topic, but we cannot treate everything in this course. </li> </ul>"},{"location":"vsc-infrastructure/","title":"VSC infrastructure","text":""},{"location":"vsc-infrastructure/#applying-for-a-guest-account-students","title":"Applying for a guest account (students)","text":"<p>Note</p> <p>The project work (see Evaluation) requires access to one of the university's HPC clusters. If you  do not already have a VSC account, you must create a SSH public/private key pair (see below how to do that) and  send it by e-mail to franky.backeljauw@uantwerpen.be with engelbert.tijskens@uantwerpen.be in cc. A  guest account will subsequently be created for you .</p>"},{"location":"vsc-infrastructure/#applying-for-a-vsc-account-researchers-from-flanders","title":"Applying for a VSC account (researchers from Flanders)","text":"<p>See Getting acces to VSC clusters.</p>"},{"location":"vsc-infrastructure/#create-an-ssh-publicprivate-key-pair","title":"Create an ssh public/private key pair","text":"<p>A ssh public/private key pair is a way for secure access to a system through the Secure Shell protocol. They are  basically two small files with matching numbers. You may think of the public key as a lock. Everyone may see the  lock but no one can open the lock without the key, which is the private part of the key pair. The public key  (the lock) will be placed on a system you need access to, in this case the Tier-2 supercomputer of our university  (currently, that is Vaughan). To access to the supercomputer (that is, open the lock) from, say, your laptop, your need the  private key to be stored on your laptop (or a USB memory stick) and pass it to the SSH protocol which will verify  the private key and the public key match and, in case they do, open the lock and grant you access.</p> <p>To create a ssh public/private key pair proceed as follows. </p>"},{"location":"vsc-infrastructure/#on-windows","title":"On Windows","text":"<p>Open<code>powershell</code> or <code>cmd</code>, and type the following command:</p> <pre><code>&gt; ssh-keygen -t rsa -b 4096\n</code></pre> <p>You will then be prompted for a file location. You may accept the default location by entering. If the files already  exist you can choose to overwrite them or to cancel the operation.</p> <pre><code>Enter file in which to save the key (C: \\Users \\your_username/ .ssh/id rsa) :\nC:\\Users\\your_username/.ssh/id rsa already exists.\nOverwrite (y/n)? y\n</code></pre> <p>You will then be prompted for a passphrase to provide an extra level of protection for in case somebody would steal the  private key. Press enter for an empty passphrase.</p> <pre><code>Enter passphrase (empty for no passphrase):\nEnter same passphrase again:\n</code></pre> <p>Finally you will be notified of where the keys are stored:  </p> <pre><code>Your identification has been saved in C: \\Users\\your_username/.ssh/id rsa.\nYour public key has been saved in C: \\Users\\your_username/.ssh/id rsa.pub.\n</code></pre> <p>Note</p> <p>Students must send their public key to franky.backeljauw@uantwerpen.be with engelbert.tijskens@uantwerpen. be in cc. If you apply for a regular VSC account, follow the procedure here. </p>"},{"location":"vsc-infrastructure/#on-linux-and-macos","title":"On Linux and MacOS","text":"<p>Open a terminal, and type the following command:</p> <pre><code>&gt; ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_vsc\n</code></pre> <p>The name <code>id_rsa_vsc</code> is arbitrary, but is best chosen to be meaningfull. You will be prompted for a passphrase to  provide an extra level of protection for in case somebody would steal the private key. Press enter for an empty  passphrase. </p> <pre><code>Generating public/private rsa key pair.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n</code></pre> <p>Finally, you will be notified of the files (=keys) created:</p> <pre><code>Your identification has been saved in /home/user/.ssh/id_rsa_vsc\nYour public key has been saved in /home/user/.ssh/id_rsa_vsc.pub\n</code></pre> <p>Note</p> <p>To obtain a guest account students must send their public key (and only their public keyto franky. backeljauw@uantwerpen.be </p> <p>with      engelbert.tijskens@uantwerpen.be in cc. </p>"}]}