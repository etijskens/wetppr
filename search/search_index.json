{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welkom bij Parallel programmeren","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Over de auteur</li> <li>Introduction</li> <li>Guide lines</li> <li>Chapter I</li> <li>Evaluation</li> <li>Assignment</li> </ol>"},{"location":"assignment/","title":"Assignment 2022-23","text":"<p>Note</p> <p>to be done ...</p>"},{"location":"chapter-1/","title":"Hoofdstuk I","text":"<p>Note</p> <p>This is work in progress. It is incomplete, unfinished and flawed, just as life. However, sometimes good enough is good enough, and it will improve with time. </p> <p>Material:</p> <ul> <li>this text, and</li> <li>this presentation.</li> </ul>"},{"location":"chapter-1/#overview","title":"Overview","text":"<ul> <li>What is a parallel program?</li> <li>Possible reasons to parallellize a program.</li> <li>When to parallallize a program, and what to do first ...</li> <li>Common approaches towards parallelization</li> <li>Case study from Molecular Dynamics</li> <li>Final remarks</li> </ul>"},{"location":"chapter-1/#what-is-a-parallel-program","title":"What is a parallel program?","text":"<p>A parallel program is a program that distributes its work over different processing units such that parts of its  work load can be computed simultaneously. At the end the program gathere the partial results from the processing  units and combines them in a global result. If the tasks are independent from each other, the program is called  embarasssingly parallel. In general, the individual tasks are not independent and need to exchange information.  This is called communication. The opposite of a parallel program is a serial or sequential program,  executing all its instructions one after the other. </p>"},{"location":"chapter-1/#possible-reasons-to-parallellize-a-program","title":"Possible reasons to parallellize a program","text":""},{"location":"chapter-1/#1-reduce-the-time-to-solution","title":"1. Reduce the time to solution","text":"<p>The term time to solution in general means the time your machine needes to solve a computational problem. If the  problem can be divided in smaller tasks that can be computed simultaneously, the time to solution decreases. If a  company can solve a research or engineering question in a week or a day, that is an important difference. A  processing unit has a maximum number of instructions it can execute per second, this is called its peak  performance. Obviously, the peak performance is a machine limit puts a hard limit to what a processing unit can  achieve in a given amount of time. But instructions operate on data, and moving data from main memory takes time as  well. A program that must process lots of data but does little computation is limited by the speed at which the  processing unit can fetch data from the main memory. This is called the memory bandwidht (usually in Mbits/s). Programs that do a lot of computation and does not move a lot of data in or out of main memory is called compute  limited. A program that moves a lot of data and little computation is bandwidth limited. While in the past  programs used to be compute bound, today, most programs are memory bound, because the speed of the processing units  increased much faster than the speed of memory. As a consequence, efficient memory acces patterns are crucial to the  performance of a program.  </p>"},{"location":"chapter-1/#2-solve-bigger-problems-in-the-same-time","title":"2. Solve bigger problems in the same time","text":"<p>There is a third machine linit that plays a role, namely the amount of main memory. This puts a limit on the size of  the problem that can be treated, e.g. the number of volume elements in a CFD simulation or the number of atoms in a  MD simulation. If the program can distribute the work over, say 10 machines, it has 10 times the amount of memory at  its disposition and thus can solve a 10 times bigger problem.  </p>"},{"location":"chapter-1/#3-produce-more-accurate-solutions","title":"3. Produce more accurate solutions","text":"<p>More accuracy can come from more complex physical models, or from using more basis functions to expand the solution. This leads to more computation and perhaps a prohibitively long time to solution. Problems involving discretisation  (the process of dividing the domain of a computational problem in small elements, as in computational fluid dynamics  and finite element modelling) the accuracy typically improves when the elements get smaller, as in approximating the  integral under a curve by rectangles. In both cases parallelizing the program may be necessary to obtain a solution. </p>"},{"location":"chapter-1/#4-competition","title":"4 Competition","text":"<p>If a program that is in competition with other programs that solve the same problem, parallelization will allow it  to reduce the time to solution, to compute bigger problems and achieve more accurate solution. This is, obviously, a  competetive advantage.  </p>"},{"location":"chapter-1/#cant-i-just-by-a-faster-and-bigger-computer","title":"Can't I just by a faster and bigger computer?","text":"<p>Nope, that fairy tale ended approximately at the beginning of this century with the advent of the multi-processor  computer. Increasing the peak performance by increasing the clock frwquency was no longer possible, because the  power consumption of a processor increases as the third power of the clock frequency. At a certain point it became  impossible or too expensive to cool the processor. The only way to get a processor execute more instructions per  second was to put more processing units on it (cores). At that point serial program became even slower on the new  multi-processors because the clock frequency was reduced to remain inside the power envelope. Moore's law predicts  that the number of transitors in a processor doubles every 18 months due to increasing miniaturization. With this the combined peak performance of the multi-prorocessors increases as well, but the peak performance of the individual  processing units no longer does. This makes it necessary to parallellize programs in order to keep up with Moore's  law. It must be said that the increase of peak performance was not always in line with Moore's law. At some point  the peak performance of processing units was increased by adding parallelization concept in single processing units  like pipelining and SIMD vectorisation. We'll come to that later.</p>"},{"location":"chapter-1/#when-to-parallelize-and-what-to-do-first","title":"When to parallelize, and what to do first ...","text":"<p>When your program takes too long, the memory of your machine is too small for your problem or the accuracy you need  cannot be met, you'rd hittin the wall. Parallelisation is necessary. However, there are things to consider first. </p> <p>Note</p> <p>unfinished ...</p>"},{"location":"evaluation/","title":"Evaluation","text":"<p>In this course you will be learning by doing. You will be given an assignment, a (parallel)  programming task on which you will work for several weeks, under my supervision and with my support. The code that  you write must be regularly committed to a GitHub repository. This has many advantages:</p> <ul> <li>First, it serves as a backup. Every single commit can be retrieved at all times. So, you can't loose your code,    even not the older versions.</li> <li>Everyone with access to the repository can access the code. If you keep the repository public, that means everyone    with access to the internet. If you make it private, only the people you invite can access. </li> <li>It is important that you give me access. If you have problems, I can clone your repository and debug it to see    what is going wrong,</li> <li>If you cooperate with another student on the project you can exchange updates easily. You can make use of git    branches to avoid bother other people with your code changes before they are correct.  </li> </ul> <p>At our final session you will give a presentation about your work</p> <ul> <li>explaining the problems you encountered,</li> <li>explaining your approach,</li> <li>providing performance measurements for the different versions your code, and for different node counts,</li> <li>explaining the performance measurements,</li> <li>explaining what you found difficult during this course.</li> </ul> <p>After the presentation I will ask some questions, mainly because I am curious and eager to learn something, but also  to ensure that you understand what you present. </p> <p>The presentation must be added to your GitHub repository before you give your presentation. I will clone it and keep  it as a proof of your results.</p>"},{"location":"guide-lines/","title":"Some guide lines","text":"<p>Note</p> <p>This is work in progress ...</p> <p>Here are some important skills that you should develop during this course:</p> <ul> <li>Understand the math of the problem and the algorithm to solve it,</li> <li>Reason about the implementation of the algorithm.</li> <li>Do research on the problem, with respect to solution algorithms and implementation issues.</li> <li>Write and debug code in Python. </li> <li>Learn how slow functions can be sped up by converting them to either C++ or Fortran. </li> <li>Run your code on one of the UAntwerp HPC clusters.</li> </ul> <p>Learning is an incremental process. Especially for scientific software development the following is a good approach:</p> <ol> <li>Try, and test (We'll see what testing exactly means). </li> <li>Fail (often, the faster you fail, the faster you learn! ).  </li> <li>Think and do research (Google - or any other good search engine, for that matter - is your best friend), and come     up with an improvement. This is the hardest part, it requires intelligence and creativity.</li> <li>Iterate, i.e. restart at 1., until you no more fail and are satisfied with the solution.</li> <li>Document your itinerary. Especially, keep track of the documents that guided you to a satisfactory solution.</li> </ol> <p>Although this approach may look as if you are supposed to find the solution to the problem in books or on the World  Wide Web, this does not at all exclude creativity at all. Learning about how other researchers approached a problem, can easily spark new ideas that get you going. The fail fast, fail often principle also urges you to start as  simple as possible and make incremental changes. Don't write a lot of code before you try and test. Typically,  and this is corroborated by research, one bug is introduced with every new 10 lines.  Finding 10 bugs in 100 lines is a lot more difficult than finding one bug in 10 lines (although sometimes there is  more than one bug :( ). </p> <p>A PhD student once asked me for support. He had written a 10 000 line Fortran program (without tests). When he ran it, the results were not what he expected and he suspected that there was a bug  'somewhere'. He asked if I could help him to find the bug and - no kidding - by the end of next week because the  program had to go into production by then. I had to disappoint him and told him that he needed a true magician,  which I am not. Obviously, the program was flawed in some sense, but other than a bug it might just as well be:</p> <ul> <li>The program contains many bugs, which is very well possible in view of its size.</li> <li>The algorithm for solving the problem is inappropriate.</li> <li>There is an accuracy problem, related e.g. discretisation of time, space, or a insufficient basis function for    expanding the solution, or related to the finite precision of floating point numbers. (Floating point numbers are a    processor's approximation of the real numbers, but they do have different mathematical properties. E.g. floating    point addition is not commutative.)</li> <li>The mathematical formulation itself could be flawed or misunderstood.</li> <li>It is even possible that the program is correct but that the researchers expectations are wrong. </li> <li>...</li> </ul> <p>It could easily take weeks, if not months to write tests for the individual components to learn aboout the behaviour  of the program and narrow down to the source of the error. </p> <p>For this reason a sound strategy for scientific software development that makes sure that the code you write has a  sense of correctness is indispensable. Had the researcher come to me before he started programming this is the  advice he would have been given: </p> <p>Advice</p> <p>Write 5 lines of code and test them before you proceed (with the next 5 lines). Just 5, not 10! Your test  code is also code and will initially contain bugs as well. As you get more experienced you may increase that  number  to 6, even 7, ...  </p> <p>Admittedly, this advice is slightly biased on the conservative side, but I hope you get the point. You will be  surprised how many mistakes you make, being a novice. But as you will discover the source of error soon, your  progress will not come to halt. Instead you will learn fast and your progress will even speed up. I will give you  practical tools to accomplish this. </p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#goals","title":"Goals","text":"<ul> <li>What is parallel programming?</li> <li>Why parallel programming?</li> <li>Performance is important</li> <li>How to parallelize a program?</li> <li>Tools</li> <li>Principles and best practices</li> <li>Strategy for scientific software development</li> </ul>"},{"location":"introduction/#background-knowledge","title":"Background knowledge","text":"<ul> <li>The working of a modern processor?</li> <li>Memory</li> <li>CPU</li> <li>Accelerators (GPU) </li> <li>The working of a supercomputer?</li> <li>Interconnect</li> </ul>"},{"location":"over-de-auteur/","title":"Over de auteur","text":""},{"location":"over-de-auteur/#engelbert-tijskens","title":"[Engel]bert Tijskens","text":"<ul> <li>Lic. Aard- en delfstofkunde, Master in Physics of Microelectronics    and Material Sciences, Doctor in de Natuurwetenschappen - ik heb dus    eigenlijk geen opleiding genoten in programmeren of wetenschappelijk    rekenen ... maar veel opleidingen bijgewoond, en vooral veel gelezen tijdens    mijn voortdurende zoektocht naar betere manieren om de opdrachten waar    ik voor stond uit te voeren.  </li> <li>ik werk sinds 2012 voor CalcUA, de UA kernfaciliteit voor    supercomputing, en voor het VSC, het Vlaams Supercomputer Centrum.   Ik verzorg er opleiding en ondersteuning van onderzoekers rond    wetenschappelijk programmeren voor HPC-omgevingen en performantie-analyse.   Ik ben gepassioneerd door Python, C++, Fortran en libraries en frameworks    waarmee hoog-performante en parallelle applicaties kunnen gebouwd worden.</li> <li>Sinds 2014 geef ik het vak \"Parallel programmeren\". Ik geef graag les   en wil mijn ervaring van 30 jaar wetenschappelijk programmeren delen met    jonge onderzoekers.</li> <li>Voor 2012 leidde ik de DEM Research Group aan de KU Leuven. DEM staat   voor Discrete Element Modelling. Je kan het vergelijken met    Molecular Dynamics, maar dan in de macroscopisch wereld met atomen    die een vorm hebben, korrels dus, of grains in het Engels. Daarom wordt    het ook Granular Dynamics genoemd. Korrelstromen komen in heel wat    industri\u00eble processen voor en het modelleren ervan is interessant,    om inzicht te verwerpen in korrelige processen en om ze te ontwerpen.    Het is erg uitdagend omdat de fysica van korrelige processen erg complex is.    In tegenstelling tot MD zijn interacties tussen grains dissipatief en worden de    contactkrachten bepaald door materiaaleigenschappen en    oppervlakteeigenschappen en zijn er zowel normale als tangenti\u00eble   contactkrachten (wrijving). Bovendien zijn de korrels - afhankelijk van het   materiaal - soms vervormbaar, of zelfs breekbaar. Omdat korrelige processen    vaak over heel veel deeltjes gaan, zijn performantie en parallellisatie    essencieel. De simulatiesoftware waar we toen aan   werkten, wordt nu gecommercialiseerd door Mpacts. </li> </ul>"},{"location":"over-de-auteur/#enkele-voorbeelden","title":"Enkele voorbeelden","text":"<p>Kijk op Mpacts case studies voor meer voorbeelden. </p>"},{"location":"over-de-auteur/#cnh-maaidorser-ontwikkeld-met-mpacts","title":"CNH maaidorser - ontwikkeld met Mpacts","text":"<p>Hier zijn verscheidene korrelige processen aan de orde:</p> <ul> <li>de strohalmen maaien en binnen trekken in de machine,</li> <li>de graantjes losmaken van de aar, scheiden van het stro,</li> <li>stro afvoeren naar achter,</li> <li>het kaf van het koren scheiden (kaf weg blazen),</li> <li>het graan transporteren naar de verzamelbak bovenaan de machine,</li> <li>het graan transporteren van de verzamelbak naar de aanhangwagen achter de tractor,</li> </ul>"},{"location":"over-de-auteur/#spherische-korrels-die-op-een-trampoline-vallen","title":"Spherische korrels die op een trampoline vallen","text":""},{"location":"over-de-auteur/#mpacts-ijsbreker","title":"Mpacts: ijsbreker","text":"<p>Mpacts ijsbreker</p>"}]}